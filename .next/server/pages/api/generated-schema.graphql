# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateCourse {
  _avg: CourseAvgAggregate
  _count: CourseCountAggregate
  _max: CourseMaxAggregate
  _min: CourseMinAggregate
  _sum: CourseSumAggregate
}

type AggregateCourseOnUser {
  _avg: CourseOnUserAvgAggregate
  _count: CourseOnUserCountAggregate
  _max: CourseOnUserMaxAggregate
  _min: CourseOnUserMinAggregate
  _sum: CourseOnUserSumAggregate
}

type AggregateFlashCard {
  _avg: FlashCardAvgAggregate
  _count: FlashCardCountAggregate
  _max: FlashCardMaxAggregate
  _min: FlashCardMinAggregate
  _sum: FlashCardSumAggregate
}

type AggregateFlashCardStack {
  _avg: FlashCardStackAvgAggregate
  _count: FlashCardStackCountAggregate
  _max: FlashCardStackMaxAggregate
  _min: FlashCardStackMinAggregate
  _sum: FlashCardStackSumAggregate
}

type AggregateFlow {
  _avg: FlowAvgAggregate
  _count: FlowCountAggregate
  _max: FlowMaxAggregate
  _min: FlowMinAggregate
  _sum: FlowSumAggregate
}

type AggregateFlowTag {
  _avg: FlowTagAvgAggregate
  _count: FlowTagCountAggregate
  _max: FlowTagMaxAggregate
  _min: FlowTagMinAggregate
  _sum: FlowTagSumAggregate
}

type AggregateFlowTagOnFlow {
  _avg: FlowTagOnFlowAvgAggregate
  _count: FlowTagOnFlowCountAggregate
  _max: FlowTagOnFlowMaxAggregate
  _min: FlowTagOnFlowMinAggregate
  _sum: FlowTagOnFlowSumAggregate
}

type AggregateProfessor {
  _avg: ProfessorAvgAggregate
  _count: ProfessorCountAggregate
  _max: ProfessorMaxAggregate
  _min: ProfessorMinAggregate
  _sum: ProfessorSumAggregate
}

type AggregateSchool {
  _avg: SchoolAvgAggregate
  _count: SchoolCountAggregate
  _max: SchoolMaxAggregate
  _min: SchoolMinAggregate
  _sum: SchoolSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type Course {
  Code: String
  CourseID: Int!
  CreatedTime: DateTime!
  FK_Professors(cursor: ProfessorWhereUniqueInput, distinct: [ProfessorScalarFieldEnum!], orderBy: [ProfessorOrderByWithRelationInput!], skip: Int, take: Int, where: ProfessorWhereInput): [Professor!]!
  FK_School: School
  FK_SchoolID: Int
  FK_Users(cursor: CourseOnUserWhereUniqueInput, distinct: [CourseOnUserScalarFieldEnum!], orderBy: [CourseOnUserOrderByWithRelationInput!], skip: Int, take: Int, where: CourseOnUserWhereInput): [CourseOnUser!]!
  IsOfficial: Boolean!
  Term: String
  Title: String
  _count: CourseCount
}

type CourseAvgAggregate {
  CourseID: Float
  FK_SchoolID: Float
}

input CourseAvgOrderByAggregateInput {
  CourseID: SortOrder
  FK_SchoolID: SortOrder
}

type CourseCount {
  FK_Professors: Int!
  FK_Users: Int!
}

type CourseCountAggregate {
  Code: Int!
  CourseID: Int!
  CreatedTime: Int!
  FK_SchoolID: Int!
  IsOfficial: Int!
  Term: Int!
  Title: Int!
  _all: Int!
}

input CourseCountOrderByAggregateInput {
  Code: SortOrder
  CourseID: SortOrder
  CreatedTime: SortOrder
  FK_SchoolID: SortOrder
  IsOfficial: SortOrder
  Term: SortOrder
  Title: SortOrder
}

input CourseCreateInput {
  Code: String
  CreatedTime: DateTime
  FK_Professors: ProfessorCreateNestedManyWithoutFK_CourseInput
  FK_School: SchoolCreateNestedOneWithoutFK_CourseInput
  FK_Users: CourseOnUserCreateNestedManyWithoutFK_CourseInput
  IsOfficial: Boolean
  Term: String
  Title: String
}

input CourseCreateManyFK_SchoolInput {
  Code: String
  CourseID: Int
  CreatedTime: DateTime
  IsOfficial: Boolean
  Term: String
  Title: String
}

input CourseCreateManyFK_SchoolInputEnvelope {
  data: [CourseCreateManyFK_SchoolInput!]!
  skipDuplicates: Boolean
}

input CourseCreateManyInput {
  Code: String
  CourseID: Int
  CreatedTime: DateTime
  FK_SchoolID: Int
  IsOfficial: Boolean
  Term: String
  Title: String
}

input CourseCreateNestedManyWithoutFK_SchoolInput {
  connect: [CourseWhereUniqueInput!]
  connectOrCreate: [CourseCreateOrConnectWithoutFK_SchoolInput!]
  create: [CourseCreateWithoutFK_SchoolInput!]
  createMany: CourseCreateManyFK_SchoolInputEnvelope
}

input CourseCreateNestedOneWithoutFK_ProfessorsInput {
  connect: CourseWhereUniqueInput
  connectOrCreate: CourseCreateOrConnectWithoutFK_ProfessorsInput
  create: CourseCreateWithoutFK_ProfessorsInput
}

input CourseCreateNestedOneWithoutFK_UsersInput {
  connect: CourseWhereUniqueInput
  connectOrCreate: CourseCreateOrConnectWithoutFK_UsersInput
  create: CourseCreateWithoutFK_UsersInput
}

input CourseCreateOrConnectWithoutFK_ProfessorsInput {
  create: CourseCreateWithoutFK_ProfessorsInput!
  where: CourseWhereUniqueInput!
}

input CourseCreateOrConnectWithoutFK_SchoolInput {
  create: CourseCreateWithoutFK_SchoolInput!
  where: CourseWhereUniqueInput!
}

input CourseCreateOrConnectWithoutFK_UsersInput {
  create: CourseCreateWithoutFK_UsersInput!
  where: CourseWhereUniqueInput!
}

input CourseCreateWithoutFK_ProfessorsInput {
  Code: String
  CreatedTime: DateTime
  FK_School: SchoolCreateNestedOneWithoutFK_CourseInput
  FK_Users: CourseOnUserCreateNestedManyWithoutFK_CourseInput
  IsOfficial: Boolean
  Term: String
  Title: String
}

input CourseCreateWithoutFK_SchoolInput {
  Code: String
  CreatedTime: DateTime
  FK_Professors: ProfessorCreateNestedManyWithoutFK_CourseInput
  FK_Users: CourseOnUserCreateNestedManyWithoutFK_CourseInput
  IsOfficial: Boolean
  Term: String
  Title: String
}

input CourseCreateWithoutFK_UsersInput {
  Code: String
  CreatedTime: DateTime
  FK_Professors: ProfessorCreateNestedManyWithoutFK_CourseInput
  FK_School: SchoolCreateNestedOneWithoutFK_CourseInput
  IsOfficial: Boolean
  Term: String
  Title: String
}

type CourseGroupBy {
  Code: String
  CourseID: Int!
  CreatedTime: DateTime!
  FK_SchoolID: Int
  IsOfficial: Boolean!
  Term: String
  Title: String
  _avg: CourseAvgAggregate
  _count: CourseCountAggregate
  _max: CourseMaxAggregate
  _min: CourseMinAggregate
  _sum: CourseSumAggregate
}

input CourseListRelationFilter {
  every: CourseWhereInput
  none: CourseWhereInput
  some: CourseWhereInput
}

type CourseMaxAggregate {
  Code: String
  CourseID: Int
  CreatedTime: DateTime
  FK_SchoolID: Int
  IsOfficial: Boolean
  Term: String
  Title: String
}

input CourseMaxOrderByAggregateInput {
  Code: SortOrder
  CourseID: SortOrder
  CreatedTime: SortOrder
  FK_SchoolID: SortOrder
  IsOfficial: SortOrder
  Term: SortOrder
  Title: SortOrder
}

type CourseMinAggregate {
  Code: String
  CourseID: Int
  CreatedTime: DateTime
  FK_SchoolID: Int
  IsOfficial: Boolean
  Term: String
  Title: String
}

input CourseMinOrderByAggregateInput {
  Code: SortOrder
  CourseID: SortOrder
  CreatedTime: SortOrder
  FK_SchoolID: SortOrder
  IsOfficial: SortOrder
  Term: SortOrder
  Title: SortOrder
}

type CourseOnUser {
  CourseOnUserID: Int!
  FK_Course: Course
  FK_CourseID: Int
  FK_User: User
  FK_UserID: Int
  HOLDER: String
}

type CourseOnUserAvgAggregate {
  CourseOnUserID: Float
  FK_CourseID: Float
  FK_UserID: Float
}

input CourseOnUserAvgOrderByAggregateInput {
  CourseOnUserID: SortOrder
  FK_CourseID: SortOrder
  FK_UserID: SortOrder
}

type CourseOnUserCountAggregate {
  CourseOnUserID: Int!
  FK_CourseID: Int!
  FK_UserID: Int!
  HOLDER: Int!
  _all: Int!
}

input CourseOnUserCountOrderByAggregateInput {
  CourseOnUserID: SortOrder
  FK_CourseID: SortOrder
  FK_UserID: SortOrder
  HOLDER: SortOrder
}

input CourseOnUserCreateInput {
  FK_Course: CourseCreateNestedOneWithoutFK_UsersInput
  FK_User: UserCreateNestedOneWithoutFK_CoursesInput
  HOLDER: String
}

input CourseOnUserCreateManyFK_CourseInput {
  CourseOnUserID: Int
  FK_UserID: Int
  HOLDER: String
}

input CourseOnUserCreateManyFK_CourseInputEnvelope {
  data: [CourseOnUserCreateManyFK_CourseInput!]!
  skipDuplicates: Boolean
}

input CourseOnUserCreateManyFK_UserInput {
  CourseOnUserID: Int
  FK_CourseID: Int
  HOLDER: String
}

input CourseOnUserCreateManyFK_UserInputEnvelope {
  data: [CourseOnUserCreateManyFK_UserInput!]!
  skipDuplicates: Boolean
}

input CourseOnUserCreateManyInput {
  CourseOnUserID: Int
  FK_CourseID: Int
  FK_UserID: Int
  HOLDER: String
}

input CourseOnUserCreateNestedManyWithoutFK_CourseInput {
  connect: [CourseOnUserWhereUniqueInput!]
  connectOrCreate: [CourseOnUserCreateOrConnectWithoutFK_CourseInput!]
  create: [CourseOnUserCreateWithoutFK_CourseInput!]
  createMany: CourseOnUserCreateManyFK_CourseInputEnvelope
}

input CourseOnUserCreateNestedManyWithoutFK_UserInput {
  connect: [CourseOnUserWhereUniqueInput!]
  connectOrCreate: [CourseOnUserCreateOrConnectWithoutFK_UserInput!]
  create: [CourseOnUserCreateWithoutFK_UserInput!]
  createMany: CourseOnUserCreateManyFK_UserInputEnvelope
}

input CourseOnUserCreateOrConnectWithoutFK_CourseInput {
  create: CourseOnUserCreateWithoutFK_CourseInput!
  where: CourseOnUserWhereUniqueInput!
}

input CourseOnUserCreateOrConnectWithoutFK_UserInput {
  create: CourseOnUserCreateWithoutFK_UserInput!
  where: CourseOnUserWhereUniqueInput!
}

input CourseOnUserCreateWithoutFK_CourseInput {
  FK_User: UserCreateNestedOneWithoutFK_CoursesInput
  HOLDER: String
}

input CourseOnUserCreateWithoutFK_UserInput {
  FK_Course: CourseCreateNestedOneWithoutFK_UsersInput
  HOLDER: String
}

type CourseOnUserGroupBy {
  CourseOnUserID: Int!
  FK_CourseID: Int
  FK_UserID: Int
  HOLDER: String
  _avg: CourseOnUserAvgAggregate
  _count: CourseOnUserCountAggregate
  _max: CourseOnUserMaxAggregate
  _min: CourseOnUserMinAggregate
  _sum: CourseOnUserSumAggregate
}

input CourseOnUserListRelationFilter {
  every: CourseOnUserWhereInput
  none: CourseOnUserWhereInput
  some: CourseOnUserWhereInput
}

type CourseOnUserMaxAggregate {
  CourseOnUserID: Int
  FK_CourseID: Int
  FK_UserID: Int
  HOLDER: String
}

input CourseOnUserMaxOrderByAggregateInput {
  CourseOnUserID: SortOrder
  FK_CourseID: SortOrder
  FK_UserID: SortOrder
  HOLDER: SortOrder
}

type CourseOnUserMinAggregate {
  CourseOnUserID: Int
  FK_CourseID: Int
  FK_UserID: Int
  HOLDER: String
}

input CourseOnUserMinOrderByAggregateInput {
  CourseOnUserID: SortOrder
  FK_CourseID: SortOrder
  FK_UserID: SortOrder
  HOLDER: SortOrder
}

input CourseOnUserOrderByRelationAggregateInput {
  _count: SortOrder
}

input CourseOnUserOrderByWithAggregationInput {
  CourseOnUserID: SortOrder
  FK_CourseID: SortOrder
  FK_UserID: SortOrder
  HOLDER: SortOrder
  _avg: CourseOnUserAvgOrderByAggregateInput
  _count: CourseOnUserCountOrderByAggregateInput
  _max: CourseOnUserMaxOrderByAggregateInput
  _min: CourseOnUserMinOrderByAggregateInput
  _sum: CourseOnUserSumOrderByAggregateInput
}

input CourseOnUserOrderByWithRelationInput {
  CourseOnUserID: SortOrder
  FK_Course: CourseOrderByWithRelationInput
  FK_CourseID: SortOrder
  FK_User: UserOrderByWithRelationInput
  FK_UserID: SortOrder
  HOLDER: SortOrder
}

enum CourseOnUserScalarFieldEnum {
  CourseOnUserID
  FK_CourseID
  FK_UserID
  HOLDER
}

input CourseOnUserScalarWhereInput {
  AND: [CourseOnUserScalarWhereInput!]
  CourseOnUserID: IntFilter
  FK_CourseID: IntNullableFilter
  FK_UserID: IntNullableFilter
  HOLDER: StringNullableFilter
  NOT: [CourseOnUserScalarWhereInput!]
  OR: [CourseOnUserScalarWhereInput!]
}

input CourseOnUserScalarWhereWithAggregatesInput {
  AND: [CourseOnUserScalarWhereWithAggregatesInput!]
  CourseOnUserID: IntWithAggregatesFilter
  FK_CourseID: IntNullableWithAggregatesFilter
  FK_UserID: IntNullableWithAggregatesFilter
  HOLDER: StringNullableWithAggregatesFilter
  NOT: [CourseOnUserScalarWhereWithAggregatesInput!]
  OR: [CourseOnUserScalarWhereWithAggregatesInput!]
}

type CourseOnUserSumAggregate {
  CourseOnUserID: Int
  FK_CourseID: Int
  FK_UserID: Int
}

input CourseOnUserSumOrderByAggregateInput {
  CourseOnUserID: SortOrder
  FK_CourseID: SortOrder
  FK_UserID: SortOrder
}

input CourseOnUserUpdateInput {
  FK_Course: CourseUpdateOneWithoutFK_UsersInput
  FK_User: UserUpdateOneWithoutFK_CoursesInput
  HOLDER: NullableStringFieldUpdateOperationsInput
}

input CourseOnUserUpdateManyMutationInput {
  HOLDER: NullableStringFieldUpdateOperationsInput
}

input CourseOnUserUpdateManyWithWhereWithoutFK_CourseInput {
  data: CourseOnUserUpdateManyMutationInput!
  where: CourseOnUserScalarWhereInput!
}

input CourseOnUserUpdateManyWithWhereWithoutFK_UserInput {
  data: CourseOnUserUpdateManyMutationInput!
  where: CourseOnUserScalarWhereInput!
}

input CourseOnUserUpdateManyWithoutFK_CourseInput {
  connect: [CourseOnUserWhereUniqueInput!]
  connectOrCreate: [CourseOnUserCreateOrConnectWithoutFK_CourseInput!]
  create: [CourseOnUserCreateWithoutFK_CourseInput!]
  createMany: CourseOnUserCreateManyFK_CourseInputEnvelope
  delete: [CourseOnUserWhereUniqueInput!]
  deleteMany: [CourseOnUserScalarWhereInput!]
  disconnect: [CourseOnUserWhereUniqueInput!]
  set: [CourseOnUserWhereUniqueInput!]
  update: [CourseOnUserUpdateWithWhereUniqueWithoutFK_CourseInput!]
  updateMany: [CourseOnUserUpdateManyWithWhereWithoutFK_CourseInput!]
  upsert: [CourseOnUserUpsertWithWhereUniqueWithoutFK_CourseInput!]
}

input CourseOnUserUpdateManyWithoutFK_UserInput {
  connect: [CourseOnUserWhereUniqueInput!]
  connectOrCreate: [CourseOnUserCreateOrConnectWithoutFK_UserInput!]
  create: [CourseOnUserCreateWithoutFK_UserInput!]
  createMany: CourseOnUserCreateManyFK_UserInputEnvelope
  delete: [CourseOnUserWhereUniqueInput!]
  deleteMany: [CourseOnUserScalarWhereInput!]
  disconnect: [CourseOnUserWhereUniqueInput!]
  set: [CourseOnUserWhereUniqueInput!]
  update: [CourseOnUserUpdateWithWhereUniqueWithoutFK_UserInput!]
  updateMany: [CourseOnUserUpdateManyWithWhereWithoutFK_UserInput!]
  upsert: [CourseOnUserUpsertWithWhereUniqueWithoutFK_UserInput!]
}

input CourseOnUserUpdateWithWhereUniqueWithoutFK_CourseInput {
  data: CourseOnUserUpdateWithoutFK_CourseInput!
  where: CourseOnUserWhereUniqueInput!
}

input CourseOnUserUpdateWithWhereUniqueWithoutFK_UserInput {
  data: CourseOnUserUpdateWithoutFK_UserInput!
  where: CourseOnUserWhereUniqueInput!
}

input CourseOnUserUpdateWithoutFK_CourseInput {
  FK_User: UserUpdateOneWithoutFK_CoursesInput
  HOLDER: NullableStringFieldUpdateOperationsInput
}

input CourseOnUserUpdateWithoutFK_UserInput {
  FK_Course: CourseUpdateOneWithoutFK_UsersInput
  HOLDER: NullableStringFieldUpdateOperationsInput
}

input CourseOnUserUpsertWithWhereUniqueWithoutFK_CourseInput {
  create: CourseOnUserCreateWithoutFK_CourseInput!
  update: CourseOnUserUpdateWithoutFK_CourseInput!
  where: CourseOnUserWhereUniqueInput!
}

input CourseOnUserUpsertWithWhereUniqueWithoutFK_UserInput {
  create: CourseOnUserCreateWithoutFK_UserInput!
  update: CourseOnUserUpdateWithoutFK_UserInput!
  where: CourseOnUserWhereUniqueInput!
}

input CourseOnUserWhereInput {
  AND: [CourseOnUserWhereInput!]
  CourseOnUserID: IntFilter
  FK_Course: CourseRelationFilter
  FK_CourseID: IntNullableFilter
  FK_User: UserRelationFilter
  FK_UserID: IntNullableFilter
  HOLDER: StringNullableFilter
  NOT: [CourseOnUserWhereInput!]
  OR: [CourseOnUserWhereInput!]
}

input CourseOnUserWhereUniqueInput {
  CourseOnUserID: Int
}

input CourseOrderByRelationAggregateInput {
  _count: SortOrder
}

input CourseOrderByWithAggregationInput {
  Code: SortOrder
  CourseID: SortOrder
  CreatedTime: SortOrder
  FK_SchoolID: SortOrder
  IsOfficial: SortOrder
  Term: SortOrder
  Title: SortOrder
  _avg: CourseAvgOrderByAggregateInput
  _count: CourseCountOrderByAggregateInput
  _max: CourseMaxOrderByAggregateInput
  _min: CourseMinOrderByAggregateInput
  _sum: CourseSumOrderByAggregateInput
}

input CourseOrderByWithRelationInput {
  Code: SortOrder
  CourseID: SortOrder
  CreatedTime: SortOrder
  FK_Professors: ProfessorOrderByRelationAggregateInput
  FK_School: SchoolOrderByWithRelationInput
  FK_SchoolID: SortOrder
  FK_Users: CourseOnUserOrderByRelationAggregateInput
  IsOfficial: SortOrder
  Term: SortOrder
  Title: SortOrder
}

input CourseRelationFilter {
  is: CourseWhereInput
  isNot: CourseWhereInput
}

enum CourseScalarFieldEnum {
  Code
  CourseID
  CreatedTime
  FK_SchoolID
  IsOfficial
  Term
  Title
}

input CourseScalarWhereInput {
  AND: [CourseScalarWhereInput!]
  Code: StringNullableFilter
  CourseID: IntFilter
  CreatedTime: DateTimeFilter
  FK_SchoolID: IntNullableFilter
  IsOfficial: BoolFilter
  NOT: [CourseScalarWhereInput!]
  OR: [CourseScalarWhereInput!]
  Term: StringNullableFilter
  Title: StringNullableFilter
}

input CourseScalarWhereWithAggregatesInput {
  AND: [CourseScalarWhereWithAggregatesInput!]
  Code: StringNullableWithAggregatesFilter
  CourseID: IntWithAggregatesFilter
  CreatedTime: DateTimeWithAggregatesFilter
  FK_SchoolID: IntNullableWithAggregatesFilter
  IsOfficial: BoolWithAggregatesFilter
  NOT: [CourseScalarWhereWithAggregatesInput!]
  OR: [CourseScalarWhereWithAggregatesInput!]
  Term: StringNullableWithAggregatesFilter
  Title: StringNullableWithAggregatesFilter
}

type CourseSumAggregate {
  CourseID: Int
  FK_SchoolID: Int
}

input CourseSumOrderByAggregateInput {
  CourseID: SortOrder
  FK_SchoolID: SortOrder
}

input CourseUpdateInput {
  Code: NullableStringFieldUpdateOperationsInput
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_Professors: ProfessorUpdateManyWithoutFK_CourseInput
  FK_School: SchoolUpdateOneWithoutFK_CourseInput
  FK_Users: CourseOnUserUpdateManyWithoutFK_CourseInput
  IsOfficial: BoolFieldUpdateOperationsInput
  Term: NullableStringFieldUpdateOperationsInput
  Title: NullableStringFieldUpdateOperationsInput
}

input CourseUpdateManyMutationInput {
  Code: NullableStringFieldUpdateOperationsInput
  CreatedTime: DateTimeFieldUpdateOperationsInput
  IsOfficial: BoolFieldUpdateOperationsInput
  Term: NullableStringFieldUpdateOperationsInput
  Title: NullableStringFieldUpdateOperationsInput
}

input CourseUpdateManyWithWhereWithoutFK_SchoolInput {
  data: CourseUpdateManyMutationInput!
  where: CourseScalarWhereInput!
}

input CourseUpdateManyWithoutFK_SchoolInput {
  connect: [CourseWhereUniqueInput!]
  connectOrCreate: [CourseCreateOrConnectWithoutFK_SchoolInput!]
  create: [CourseCreateWithoutFK_SchoolInput!]
  createMany: CourseCreateManyFK_SchoolInputEnvelope
  delete: [CourseWhereUniqueInput!]
  deleteMany: [CourseScalarWhereInput!]
  disconnect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutFK_SchoolInput!]
  updateMany: [CourseUpdateManyWithWhereWithoutFK_SchoolInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutFK_SchoolInput!]
}

input CourseUpdateOneWithoutFK_ProfessorsInput {
  connect: CourseWhereUniqueInput
  connectOrCreate: CourseCreateOrConnectWithoutFK_ProfessorsInput
  create: CourseCreateWithoutFK_ProfessorsInput
  delete: Boolean
  disconnect: Boolean
  update: CourseUpdateWithoutFK_ProfessorsInput
  upsert: CourseUpsertWithoutFK_ProfessorsInput
}

input CourseUpdateOneWithoutFK_UsersInput {
  connect: CourseWhereUniqueInput
  connectOrCreate: CourseCreateOrConnectWithoutFK_UsersInput
  create: CourseCreateWithoutFK_UsersInput
  delete: Boolean
  disconnect: Boolean
  update: CourseUpdateWithoutFK_UsersInput
  upsert: CourseUpsertWithoutFK_UsersInput
}

input CourseUpdateWithWhereUniqueWithoutFK_SchoolInput {
  data: CourseUpdateWithoutFK_SchoolInput!
  where: CourseWhereUniqueInput!
}

input CourseUpdateWithoutFK_ProfessorsInput {
  Code: NullableStringFieldUpdateOperationsInput
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_School: SchoolUpdateOneWithoutFK_CourseInput
  FK_Users: CourseOnUserUpdateManyWithoutFK_CourseInput
  IsOfficial: BoolFieldUpdateOperationsInput
  Term: NullableStringFieldUpdateOperationsInput
  Title: NullableStringFieldUpdateOperationsInput
}

input CourseUpdateWithoutFK_SchoolInput {
  Code: NullableStringFieldUpdateOperationsInput
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_Professors: ProfessorUpdateManyWithoutFK_CourseInput
  FK_Users: CourseOnUserUpdateManyWithoutFK_CourseInput
  IsOfficial: BoolFieldUpdateOperationsInput
  Term: NullableStringFieldUpdateOperationsInput
  Title: NullableStringFieldUpdateOperationsInput
}

input CourseUpdateWithoutFK_UsersInput {
  Code: NullableStringFieldUpdateOperationsInput
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_Professors: ProfessorUpdateManyWithoutFK_CourseInput
  FK_School: SchoolUpdateOneWithoutFK_CourseInput
  IsOfficial: BoolFieldUpdateOperationsInput
  Term: NullableStringFieldUpdateOperationsInput
  Title: NullableStringFieldUpdateOperationsInput
}

input CourseUpsertWithWhereUniqueWithoutFK_SchoolInput {
  create: CourseCreateWithoutFK_SchoolInput!
  update: CourseUpdateWithoutFK_SchoolInput!
  where: CourseWhereUniqueInput!
}

input CourseUpsertWithoutFK_ProfessorsInput {
  create: CourseCreateWithoutFK_ProfessorsInput!
  update: CourseUpdateWithoutFK_ProfessorsInput!
}

input CourseUpsertWithoutFK_UsersInput {
  create: CourseCreateWithoutFK_UsersInput!
  update: CourseUpdateWithoutFK_UsersInput!
}

input CourseWhereInput {
  AND: [CourseWhereInput!]
  Code: StringNullableFilter
  CourseID: IntFilter
  CreatedTime: DateTimeFilter
  FK_Professors: ProfessorListRelationFilter
  FK_School: SchoolRelationFilter
  FK_SchoolID: IntNullableFilter
  FK_Users: CourseOnUserListRelationFilter
  IsOfficial: BoolFilter
  NOT: [CourseWhereInput!]
  OR: [CourseWhereInput!]
  Term: StringNullableFilter
  Title: StringNullableFilter
}

input CourseWhereUniqueInput {
  CourseID: Int
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumVisibilityNullableFilter {
  equals: Visibility
  in: [Visibility!]
  not: NestedEnumVisibilityNullableFilter
  notIn: [Visibility!]
}

input EnumVisibilityNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedEnumVisibilityNullableFilter
  _min: NestedEnumVisibilityNullableFilter
  equals: Visibility
  in: [Visibility!]
  not: NestedEnumVisibilityNullableWithAggregatesFilter
  notIn: [Visibility!]
}

type FlashCard {
  Back: String
  CreatedTime: DateTime!
  FK_FlashCardStack: FlashCardStack
  FK_FlashCardStackID: Int
  FlashCardID: Int!
  Front: String
  Position: Int!
}

type FlashCardAvgAggregate {
  FK_FlashCardStackID: Float
  FlashCardID: Float
  Position: Float
}

input FlashCardAvgOrderByAggregateInput {
  FK_FlashCardStackID: SortOrder
  FlashCardID: SortOrder
  Position: SortOrder
}

type FlashCardCountAggregate {
  Back: Int!
  CreatedTime: Int!
  FK_FlashCardStackID: Int!
  FlashCardID: Int!
  Front: Int!
  Position: Int!
  _all: Int!
}

input FlashCardCountOrderByAggregateInput {
  Back: SortOrder
  CreatedTime: SortOrder
  FK_FlashCardStackID: SortOrder
  FlashCardID: SortOrder
  Front: SortOrder
  Position: SortOrder
}

input FlashCardCreateInput {
  Back: String
  CreatedTime: DateTime
  FK_FlashCardStack: FlashCardStackCreateNestedOneWithoutFK_FlashcardsInput
  Front: String
  Position: Int!
}

input FlashCardCreateManyFK_FlashCardStackInput {
  Back: String
  CreatedTime: DateTime
  FlashCardID: Int
  Front: String
  Position: Int!
}

input FlashCardCreateManyFK_FlashCardStackInputEnvelope {
  data: [FlashCardCreateManyFK_FlashCardStackInput!]!
  skipDuplicates: Boolean
}

input FlashCardCreateManyInput {
  Back: String
  CreatedTime: DateTime
  FK_FlashCardStackID: Int
  FlashCardID: Int
  Front: String
  Position: Int!
}

input FlashCardCreateNestedManyWithoutFK_FlashCardStackInput {
  connect: [FlashCardWhereUniqueInput!]
  connectOrCreate: [FlashCardCreateOrConnectWithoutFK_FlashCardStackInput!]
  create: [FlashCardCreateWithoutFK_FlashCardStackInput!]
  createMany: FlashCardCreateManyFK_FlashCardStackInputEnvelope
}

input FlashCardCreateOrConnectWithoutFK_FlashCardStackInput {
  create: FlashCardCreateWithoutFK_FlashCardStackInput!
  where: FlashCardWhereUniqueInput!
}

input FlashCardCreateWithoutFK_FlashCardStackInput {
  Back: String
  CreatedTime: DateTime
  Front: String
  Position: Int!
}

type FlashCardGroupBy {
  Back: String
  CreatedTime: DateTime!
  FK_FlashCardStackID: Int
  FlashCardID: Int!
  Front: String
  Position: Int!
  _avg: FlashCardAvgAggregate
  _count: FlashCardCountAggregate
  _max: FlashCardMaxAggregate
  _min: FlashCardMinAggregate
  _sum: FlashCardSumAggregate
}

input FlashCardListRelationFilter {
  every: FlashCardWhereInput
  none: FlashCardWhereInput
  some: FlashCardWhereInput
}

type FlashCardMaxAggregate {
  Back: String
  CreatedTime: DateTime
  FK_FlashCardStackID: Int
  FlashCardID: Int
  Front: String
  Position: Int
}

input FlashCardMaxOrderByAggregateInput {
  Back: SortOrder
  CreatedTime: SortOrder
  FK_FlashCardStackID: SortOrder
  FlashCardID: SortOrder
  Front: SortOrder
  Position: SortOrder
}

type FlashCardMinAggregate {
  Back: String
  CreatedTime: DateTime
  FK_FlashCardStackID: Int
  FlashCardID: Int
  Front: String
  Position: Int
}

input FlashCardMinOrderByAggregateInput {
  Back: SortOrder
  CreatedTime: SortOrder
  FK_FlashCardStackID: SortOrder
  FlashCardID: SortOrder
  Front: SortOrder
  Position: SortOrder
}

input FlashCardOrderByRelationAggregateInput {
  _count: SortOrder
}

input FlashCardOrderByWithAggregationInput {
  Back: SortOrder
  CreatedTime: SortOrder
  FK_FlashCardStackID: SortOrder
  FlashCardID: SortOrder
  Front: SortOrder
  Position: SortOrder
  _avg: FlashCardAvgOrderByAggregateInput
  _count: FlashCardCountOrderByAggregateInput
  _max: FlashCardMaxOrderByAggregateInput
  _min: FlashCardMinOrderByAggregateInput
  _sum: FlashCardSumOrderByAggregateInput
}

input FlashCardOrderByWithRelationInput {
  Back: SortOrder
  CreatedTime: SortOrder
  FK_FlashCardStack: FlashCardStackOrderByWithRelationInput
  FK_FlashCardStackID: SortOrder
  FlashCardID: SortOrder
  Front: SortOrder
  Position: SortOrder
}

enum FlashCardScalarFieldEnum {
  Back
  CreatedTime
  FK_FlashCardStackID
  FlashCardID
  Front
  Position
}

input FlashCardScalarWhereInput {
  AND: [FlashCardScalarWhereInput!]
  Back: StringNullableFilter
  CreatedTime: DateTimeFilter
  FK_FlashCardStackID: IntNullableFilter
  FlashCardID: IntFilter
  Front: StringNullableFilter
  NOT: [FlashCardScalarWhereInput!]
  OR: [FlashCardScalarWhereInput!]
  Position: IntFilter
}

input FlashCardScalarWhereWithAggregatesInput {
  AND: [FlashCardScalarWhereWithAggregatesInput!]
  Back: StringNullableWithAggregatesFilter
  CreatedTime: DateTimeWithAggregatesFilter
  FK_FlashCardStackID: IntNullableWithAggregatesFilter
  FlashCardID: IntWithAggregatesFilter
  Front: StringNullableWithAggregatesFilter
  NOT: [FlashCardScalarWhereWithAggregatesInput!]
  OR: [FlashCardScalarWhereWithAggregatesInput!]
  Position: IntWithAggregatesFilter
}

type FlashCardStack {
  CreatedTime: DateTime!
  FK_Flashcards(cursor: FlashCardWhereUniqueInput, distinct: [FlashCardScalarFieldEnum!], orderBy: [FlashCardOrderByWithRelationInput!], skip: Int, take: Int, where: FlashCardWhereInput): [FlashCard!]!
  FK_Flow: Flow
  FK_FlowID: Int
  FK_User: User
  FK_UserID: Int
  FlashCardStackID: Int!
  Title: String
  _count: FlashCardStackCount
}

type FlashCardStackAvgAggregate {
  FK_FlowID: Float
  FK_UserID: Float
  FlashCardStackID: Float
}

input FlashCardStackAvgOrderByAggregateInput {
  FK_FlowID: SortOrder
  FK_UserID: SortOrder
  FlashCardStackID: SortOrder
}

type FlashCardStackCount {
  FK_Flashcards: Int!
}

type FlashCardStackCountAggregate {
  CreatedTime: Int!
  FK_FlowID: Int!
  FK_UserID: Int!
  FlashCardStackID: Int!
  Title: Int!
  _all: Int!
}

input FlashCardStackCountOrderByAggregateInput {
  CreatedTime: SortOrder
  FK_FlowID: SortOrder
  FK_UserID: SortOrder
  FlashCardStackID: SortOrder
  Title: SortOrder
}

input FlashCardStackCreateInput {
  CreatedTime: DateTime
  FK_Flashcards: FlashCardCreateNestedManyWithoutFK_FlashCardStackInput
  FK_Flow: FlowCreateNestedOneWithoutFK_FlashCardStacksInput
  FK_User: UserCreateNestedOneWithoutFK_FlashCardStacksInput
  Title: String
}

input FlashCardStackCreateManyFK_FlowInput {
  CreatedTime: DateTime
  FK_UserID: Int
  FlashCardStackID: Int
  Title: String
}

input FlashCardStackCreateManyFK_FlowInputEnvelope {
  data: [FlashCardStackCreateManyFK_FlowInput!]!
  skipDuplicates: Boolean
}

input FlashCardStackCreateManyFK_UserInput {
  CreatedTime: DateTime
  FK_FlowID: Int
  FlashCardStackID: Int
  Title: String
}

input FlashCardStackCreateManyFK_UserInputEnvelope {
  data: [FlashCardStackCreateManyFK_UserInput!]!
  skipDuplicates: Boolean
}

input FlashCardStackCreateManyInput {
  CreatedTime: DateTime
  FK_FlowID: Int
  FK_UserID: Int
  FlashCardStackID: Int
  Title: String
}

input FlashCardStackCreateNestedManyWithoutFK_FlowInput {
  connect: [FlashCardStackWhereUniqueInput!]
  connectOrCreate: [FlashCardStackCreateOrConnectWithoutFK_FlowInput!]
  create: [FlashCardStackCreateWithoutFK_FlowInput!]
  createMany: FlashCardStackCreateManyFK_FlowInputEnvelope
}

input FlashCardStackCreateNestedManyWithoutFK_UserInput {
  connect: [FlashCardStackWhereUniqueInput!]
  connectOrCreate: [FlashCardStackCreateOrConnectWithoutFK_UserInput!]
  create: [FlashCardStackCreateWithoutFK_UserInput!]
  createMany: FlashCardStackCreateManyFK_UserInputEnvelope
}

input FlashCardStackCreateNestedOneWithoutFK_FlashcardsInput {
  connect: FlashCardStackWhereUniqueInput
  connectOrCreate: FlashCardStackCreateOrConnectWithoutFK_FlashcardsInput
  create: FlashCardStackCreateWithoutFK_FlashcardsInput
}

input FlashCardStackCreateOrConnectWithoutFK_FlashcardsInput {
  create: FlashCardStackCreateWithoutFK_FlashcardsInput!
  where: FlashCardStackWhereUniqueInput!
}

input FlashCardStackCreateOrConnectWithoutFK_FlowInput {
  create: FlashCardStackCreateWithoutFK_FlowInput!
  where: FlashCardStackWhereUniqueInput!
}

input FlashCardStackCreateOrConnectWithoutFK_UserInput {
  create: FlashCardStackCreateWithoutFK_UserInput!
  where: FlashCardStackWhereUniqueInput!
}

input FlashCardStackCreateWithoutFK_FlashcardsInput {
  CreatedTime: DateTime
  FK_Flow: FlowCreateNestedOneWithoutFK_FlashCardStacksInput
  FK_User: UserCreateNestedOneWithoutFK_FlashCardStacksInput
  Title: String
}

input FlashCardStackCreateWithoutFK_FlowInput {
  CreatedTime: DateTime
  FK_Flashcards: FlashCardCreateNestedManyWithoutFK_FlashCardStackInput
  FK_User: UserCreateNestedOneWithoutFK_FlashCardStacksInput
  Title: String
}

input FlashCardStackCreateWithoutFK_UserInput {
  CreatedTime: DateTime
  FK_Flashcards: FlashCardCreateNestedManyWithoutFK_FlashCardStackInput
  FK_Flow: FlowCreateNestedOneWithoutFK_FlashCardStacksInput
  Title: String
}

type FlashCardStackGroupBy {
  CreatedTime: DateTime!
  FK_FlowID: Int
  FK_UserID: Int
  FlashCardStackID: Int!
  Title: String
  _avg: FlashCardStackAvgAggregate
  _count: FlashCardStackCountAggregate
  _max: FlashCardStackMaxAggregate
  _min: FlashCardStackMinAggregate
  _sum: FlashCardStackSumAggregate
}

input FlashCardStackListRelationFilter {
  every: FlashCardStackWhereInput
  none: FlashCardStackWhereInput
  some: FlashCardStackWhereInput
}

type FlashCardStackMaxAggregate {
  CreatedTime: DateTime
  FK_FlowID: Int
  FK_UserID: Int
  FlashCardStackID: Int
  Title: String
}

input FlashCardStackMaxOrderByAggregateInput {
  CreatedTime: SortOrder
  FK_FlowID: SortOrder
  FK_UserID: SortOrder
  FlashCardStackID: SortOrder
  Title: SortOrder
}

type FlashCardStackMinAggregate {
  CreatedTime: DateTime
  FK_FlowID: Int
  FK_UserID: Int
  FlashCardStackID: Int
  Title: String
}

input FlashCardStackMinOrderByAggregateInput {
  CreatedTime: SortOrder
  FK_FlowID: SortOrder
  FK_UserID: SortOrder
  FlashCardStackID: SortOrder
  Title: SortOrder
}

input FlashCardStackOrderByRelationAggregateInput {
  _count: SortOrder
}

input FlashCardStackOrderByWithAggregationInput {
  CreatedTime: SortOrder
  FK_FlowID: SortOrder
  FK_UserID: SortOrder
  FlashCardStackID: SortOrder
  Title: SortOrder
  _avg: FlashCardStackAvgOrderByAggregateInput
  _count: FlashCardStackCountOrderByAggregateInput
  _max: FlashCardStackMaxOrderByAggregateInput
  _min: FlashCardStackMinOrderByAggregateInput
  _sum: FlashCardStackSumOrderByAggregateInput
}

input FlashCardStackOrderByWithRelationInput {
  CreatedTime: SortOrder
  FK_Flashcards: FlashCardOrderByRelationAggregateInput
  FK_Flow: FlowOrderByWithRelationInput
  FK_FlowID: SortOrder
  FK_User: UserOrderByWithRelationInput
  FK_UserID: SortOrder
  FlashCardStackID: SortOrder
  Title: SortOrder
}

input FlashCardStackRelationFilter {
  is: FlashCardStackWhereInput
  isNot: FlashCardStackWhereInput
}

enum FlashCardStackScalarFieldEnum {
  CreatedTime
  FK_FlowID
  FK_UserID
  FlashCardStackID
  Title
}

input FlashCardStackScalarWhereInput {
  AND: [FlashCardStackScalarWhereInput!]
  CreatedTime: DateTimeFilter
  FK_FlowID: IntNullableFilter
  FK_UserID: IntNullableFilter
  FlashCardStackID: IntFilter
  NOT: [FlashCardStackScalarWhereInput!]
  OR: [FlashCardStackScalarWhereInput!]
  Title: StringNullableFilter
}

input FlashCardStackScalarWhereWithAggregatesInput {
  AND: [FlashCardStackScalarWhereWithAggregatesInput!]
  CreatedTime: DateTimeWithAggregatesFilter
  FK_FlowID: IntNullableWithAggregatesFilter
  FK_UserID: IntNullableWithAggregatesFilter
  FlashCardStackID: IntWithAggregatesFilter
  NOT: [FlashCardStackScalarWhereWithAggregatesInput!]
  OR: [FlashCardStackScalarWhereWithAggregatesInput!]
  Title: StringNullableWithAggregatesFilter
}

type FlashCardStackSumAggregate {
  FK_FlowID: Int
  FK_UserID: Int
  FlashCardStackID: Int
}

input FlashCardStackSumOrderByAggregateInput {
  FK_FlowID: SortOrder
  FK_UserID: SortOrder
  FlashCardStackID: SortOrder
}

input FlashCardStackUpdateInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_Flashcards: FlashCardUpdateManyWithoutFK_FlashCardStackInput
  FK_Flow: FlowUpdateOneWithoutFK_FlashCardStacksInput
  FK_User: UserUpdateOneWithoutFK_FlashCardStacksInput
  Title: NullableStringFieldUpdateOperationsInput
}

input FlashCardStackUpdateManyMutationInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  Title: NullableStringFieldUpdateOperationsInput
}

input FlashCardStackUpdateManyWithWhereWithoutFK_FlowInput {
  data: FlashCardStackUpdateManyMutationInput!
  where: FlashCardStackScalarWhereInput!
}

input FlashCardStackUpdateManyWithWhereWithoutFK_UserInput {
  data: FlashCardStackUpdateManyMutationInput!
  where: FlashCardStackScalarWhereInput!
}

input FlashCardStackUpdateManyWithoutFK_FlowInput {
  connect: [FlashCardStackWhereUniqueInput!]
  connectOrCreate: [FlashCardStackCreateOrConnectWithoutFK_FlowInput!]
  create: [FlashCardStackCreateWithoutFK_FlowInput!]
  createMany: FlashCardStackCreateManyFK_FlowInputEnvelope
  delete: [FlashCardStackWhereUniqueInput!]
  deleteMany: [FlashCardStackScalarWhereInput!]
  disconnect: [FlashCardStackWhereUniqueInput!]
  set: [FlashCardStackWhereUniqueInput!]
  update: [FlashCardStackUpdateWithWhereUniqueWithoutFK_FlowInput!]
  updateMany: [FlashCardStackUpdateManyWithWhereWithoutFK_FlowInput!]
  upsert: [FlashCardStackUpsertWithWhereUniqueWithoutFK_FlowInput!]
}

input FlashCardStackUpdateManyWithoutFK_UserInput {
  connect: [FlashCardStackWhereUniqueInput!]
  connectOrCreate: [FlashCardStackCreateOrConnectWithoutFK_UserInput!]
  create: [FlashCardStackCreateWithoutFK_UserInput!]
  createMany: FlashCardStackCreateManyFK_UserInputEnvelope
  delete: [FlashCardStackWhereUniqueInput!]
  deleteMany: [FlashCardStackScalarWhereInput!]
  disconnect: [FlashCardStackWhereUniqueInput!]
  set: [FlashCardStackWhereUniqueInput!]
  update: [FlashCardStackUpdateWithWhereUniqueWithoutFK_UserInput!]
  updateMany: [FlashCardStackUpdateManyWithWhereWithoutFK_UserInput!]
  upsert: [FlashCardStackUpsertWithWhereUniqueWithoutFK_UserInput!]
}

input FlashCardStackUpdateOneWithoutFK_FlashcardsInput {
  connect: FlashCardStackWhereUniqueInput
  connectOrCreate: FlashCardStackCreateOrConnectWithoutFK_FlashcardsInput
  create: FlashCardStackCreateWithoutFK_FlashcardsInput
  delete: Boolean
  disconnect: Boolean
  update: FlashCardStackUpdateWithoutFK_FlashcardsInput
  upsert: FlashCardStackUpsertWithoutFK_FlashcardsInput
}

input FlashCardStackUpdateWithWhereUniqueWithoutFK_FlowInput {
  data: FlashCardStackUpdateWithoutFK_FlowInput!
  where: FlashCardStackWhereUniqueInput!
}

input FlashCardStackUpdateWithWhereUniqueWithoutFK_UserInput {
  data: FlashCardStackUpdateWithoutFK_UserInput!
  where: FlashCardStackWhereUniqueInput!
}

input FlashCardStackUpdateWithoutFK_FlashcardsInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_Flow: FlowUpdateOneWithoutFK_FlashCardStacksInput
  FK_User: UserUpdateOneWithoutFK_FlashCardStacksInput
  Title: NullableStringFieldUpdateOperationsInput
}

input FlashCardStackUpdateWithoutFK_FlowInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_Flashcards: FlashCardUpdateManyWithoutFK_FlashCardStackInput
  FK_User: UserUpdateOneWithoutFK_FlashCardStacksInput
  Title: NullableStringFieldUpdateOperationsInput
}

input FlashCardStackUpdateWithoutFK_UserInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_Flashcards: FlashCardUpdateManyWithoutFK_FlashCardStackInput
  FK_Flow: FlowUpdateOneWithoutFK_FlashCardStacksInput
  Title: NullableStringFieldUpdateOperationsInput
}

input FlashCardStackUpsertWithWhereUniqueWithoutFK_FlowInput {
  create: FlashCardStackCreateWithoutFK_FlowInput!
  update: FlashCardStackUpdateWithoutFK_FlowInput!
  where: FlashCardStackWhereUniqueInput!
}

input FlashCardStackUpsertWithWhereUniqueWithoutFK_UserInput {
  create: FlashCardStackCreateWithoutFK_UserInput!
  update: FlashCardStackUpdateWithoutFK_UserInput!
  where: FlashCardStackWhereUniqueInput!
}

input FlashCardStackUpsertWithoutFK_FlashcardsInput {
  create: FlashCardStackCreateWithoutFK_FlashcardsInput!
  update: FlashCardStackUpdateWithoutFK_FlashcardsInput!
}

input FlashCardStackWhereInput {
  AND: [FlashCardStackWhereInput!]
  CreatedTime: DateTimeFilter
  FK_Flashcards: FlashCardListRelationFilter
  FK_Flow: FlowRelationFilter
  FK_FlowID: IntNullableFilter
  FK_User: UserRelationFilter
  FK_UserID: IntNullableFilter
  FlashCardStackID: IntFilter
  NOT: [FlashCardStackWhereInput!]
  OR: [FlashCardStackWhereInput!]
  Title: StringNullableFilter
}

input FlashCardStackWhereUniqueInput {
  FlashCardStackID: Int
}

type FlashCardSumAggregate {
  FK_FlashCardStackID: Int
  FlashCardID: Int
  Position: Int
}

input FlashCardSumOrderByAggregateInput {
  FK_FlashCardStackID: SortOrder
  FlashCardID: SortOrder
  Position: SortOrder
}

input FlashCardUpdateInput {
  Back: NullableStringFieldUpdateOperationsInput
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_FlashCardStack: FlashCardStackUpdateOneWithoutFK_FlashcardsInput
  Front: NullableStringFieldUpdateOperationsInput
  Position: IntFieldUpdateOperationsInput
}

input FlashCardUpdateManyMutationInput {
  Back: NullableStringFieldUpdateOperationsInput
  CreatedTime: DateTimeFieldUpdateOperationsInput
  Front: NullableStringFieldUpdateOperationsInput
  Position: IntFieldUpdateOperationsInput
}

input FlashCardUpdateManyWithWhereWithoutFK_FlashCardStackInput {
  data: FlashCardUpdateManyMutationInput!
  where: FlashCardScalarWhereInput!
}

input FlashCardUpdateManyWithoutFK_FlashCardStackInput {
  connect: [FlashCardWhereUniqueInput!]
  connectOrCreate: [FlashCardCreateOrConnectWithoutFK_FlashCardStackInput!]
  create: [FlashCardCreateWithoutFK_FlashCardStackInput!]
  createMany: FlashCardCreateManyFK_FlashCardStackInputEnvelope
  delete: [FlashCardWhereUniqueInput!]
  deleteMany: [FlashCardScalarWhereInput!]
  disconnect: [FlashCardWhereUniqueInput!]
  set: [FlashCardWhereUniqueInput!]
  update: [FlashCardUpdateWithWhereUniqueWithoutFK_FlashCardStackInput!]
  updateMany: [FlashCardUpdateManyWithWhereWithoutFK_FlashCardStackInput!]
  upsert: [FlashCardUpsertWithWhereUniqueWithoutFK_FlashCardStackInput!]
}

input FlashCardUpdateWithWhereUniqueWithoutFK_FlashCardStackInput {
  data: FlashCardUpdateWithoutFK_FlashCardStackInput!
  where: FlashCardWhereUniqueInput!
}

input FlashCardUpdateWithoutFK_FlashCardStackInput {
  Back: NullableStringFieldUpdateOperationsInput
  CreatedTime: DateTimeFieldUpdateOperationsInput
  Front: NullableStringFieldUpdateOperationsInput
  Position: IntFieldUpdateOperationsInput
}

input FlashCardUpsertWithWhereUniqueWithoutFK_FlashCardStackInput {
  create: FlashCardCreateWithoutFK_FlashCardStackInput!
  update: FlashCardUpdateWithoutFK_FlashCardStackInput!
  where: FlashCardWhereUniqueInput!
}

input FlashCardWhereInput {
  AND: [FlashCardWhereInput!]
  Back: StringNullableFilter
  CreatedTime: DateTimeFilter
  FK_FlashCardStack: FlashCardStackRelationFilter
  FK_FlashCardStackID: IntNullableFilter
  FlashCardID: IntFilter
  Front: StringNullableFilter
  NOT: [FlashCardWhereInput!]
  OR: [FlashCardWhereInput!]
  Position: IntFilter
}

input FlashCardWhereUniqueInput {
  FlashCardID: Int
}

type Flow {
  Body: String
  CreatedTime: DateTime!
  FK_FlashCardStacks(cursor: FlashCardStackWhereUniqueInput, distinct: [FlashCardStackScalarFieldEnum!], orderBy: [FlashCardStackOrderByWithRelationInput!], skip: Int, take: Int, where: FlashCardStackWhereInput): [FlashCardStack!]!
  FK_Tags(cursor: FlowTagOnFlowWhereUniqueInput, distinct: [FlowTagOnFlowScalarFieldEnum!], orderBy: [FlowTagOnFlowOrderByWithRelationInput!], skip: Int, take: Int, where: FlowTagOnFlowWhereInput): [FlowTagOnFlow!]!
  FK_User: User
  FK_UserID: Int
  FlowID: Int!
  Title: String
  Visibility: Visibility
  _count: FlowCount
}

type FlowAvgAggregate {
  FK_UserID: Float
  FlowID: Float
}

input FlowAvgOrderByAggregateInput {
  FK_UserID: SortOrder
  FlowID: SortOrder
}

type FlowCount {
  FK_FlashCardStacks: Int!
  FK_Tags: Int!
}

type FlowCountAggregate {
  Body: Int!
  CreatedTime: Int!
  FK_UserID: Int!
  FlowID: Int!
  Title: Int!
  Visibility: Int!
  _all: Int!
}

input FlowCountOrderByAggregateInput {
  Body: SortOrder
  CreatedTime: SortOrder
  FK_UserID: SortOrder
  FlowID: SortOrder
  Title: SortOrder
  Visibility: SortOrder
}

input FlowCreateInput {
  Body: String
  CreatedTime: DateTime
  FK_FlashCardStacks: FlashCardStackCreateNestedManyWithoutFK_FlowInput
  FK_Tags: FlowTagOnFlowCreateNestedManyWithoutFK_FlowInput
  FK_User: UserCreateNestedOneWithoutFK_FlowsInput
  Title: String
  Visibility: Visibility
}

input FlowCreateManyFK_UserInput {
  Body: String
  CreatedTime: DateTime
  FlowID: Int
  Title: String
  Visibility: Visibility
}

input FlowCreateManyFK_UserInputEnvelope {
  data: [FlowCreateManyFK_UserInput!]!
  skipDuplicates: Boolean
}

input FlowCreateManyInput {
  Body: String
  CreatedTime: DateTime
  FK_UserID: Int
  FlowID: Int
  Title: String
  Visibility: Visibility
}

input FlowCreateNestedManyWithoutFK_UserInput {
  connect: [FlowWhereUniqueInput!]
  connectOrCreate: [FlowCreateOrConnectWithoutFK_UserInput!]
  create: [FlowCreateWithoutFK_UserInput!]
  createMany: FlowCreateManyFK_UserInputEnvelope
}

input FlowCreateNestedOneWithoutFK_FlashCardStacksInput {
  connect: FlowWhereUniqueInput
  connectOrCreate: FlowCreateOrConnectWithoutFK_FlashCardStacksInput
  create: FlowCreateWithoutFK_FlashCardStacksInput
}

input FlowCreateNestedOneWithoutFK_TagsInput {
  connect: FlowWhereUniqueInput
  connectOrCreate: FlowCreateOrConnectWithoutFK_TagsInput
  create: FlowCreateWithoutFK_TagsInput
}

input FlowCreateOrConnectWithoutFK_FlashCardStacksInput {
  create: FlowCreateWithoutFK_FlashCardStacksInput!
  where: FlowWhereUniqueInput!
}

input FlowCreateOrConnectWithoutFK_TagsInput {
  create: FlowCreateWithoutFK_TagsInput!
  where: FlowWhereUniqueInput!
}

input FlowCreateOrConnectWithoutFK_UserInput {
  create: FlowCreateWithoutFK_UserInput!
  where: FlowWhereUniqueInput!
}

input FlowCreateWithoutFK_FlashCardStacksInput {
  Body: String
  CreatedTime: DateTime
  FK_Tags: FlowTagOnFlowCreateNestedManyWithoutFK_FlowInput
  FK_User: UserCreateNestedOneWithoutFK_FlowsInput
  Title: String
  Visibility: Visibility
}

input FlowCreateWithoutFK_TagsInput {
  Body: String
  CreatedTime: DateTime
  FK_FlashCardStacks: FlashCardStackCreateNestedManyWithoutFK_FlowInput
  FK_User: UserCreateNestedOneWithoutFK_FlowsInput
  Title: String
  Visibility: Visibility
}

input FlowCreateWithoutFK_UserInput {
  Body: String
  CreatedTime: DateTime
  FK_FlashCardStacks: FlashCardStackCreateNestedManyWithoutFK_FlowInput
  FK_Tags: FlowTagOnFlowCreateNestedManyWithoutFK_FlowInput
  Title: String
  Visibility: Visibility
}

type FlowGroupBy {
  Body: String
  CreatedTime: DateTime!
  FK_UserID: Int
  FlowID: Int!
  Title: String
  Visibility: Visibility
  _avg: FlowAvgAggregate
  _count: FlowCountAggregate
  _max: FlowMaxAggregate
  _min: FlowMinAggregate
  _sum: FlowSumAggregate
}

input FlowListRelationFilter {
  every: FlowWhereInput
  none: FlowWhereInput
  some: FlowWhereInput
}

type FlowMaxAggregate {
  Body: String
  CreatedTime: DateTime
  FK_UserID: Int
  FlowID: Int
  Title: String
  Visibility: Visibility
}

input FlowMaxOrderByAggregateInput {
  Body: SortOrder
  CreatedTime: SortOrder
  FK_UserID: SortOrder
  FlowID: SortOrder
  Title: SortOrder
  Visibility: SortOrder
}

type FlowMinAggregate {
  Body: String
  CreatedTime: DateTime
  FK_UserID: Int
  FlowID: Int
  Title: String
  Visibility: Visibility
}

input FlowMinOrderByAggregateInput {
  Body: SortOrder
  CreatedTime: SortOrder
  FK_UserID: SortOrder
  FlowID: SortOrder
  Title: SortOrder
  Visibility: SortOrder
}

input FlowOrderByRelationAggregateInput {
  _count: SortOrder
}

input FlowOrderByWithAggregationInput {
  Body: SortOrder
  CreatedTime: SortOrder
  FK_UserID: SortOrder
  FlowID: SortOrder
  Title: SortOrder
  Visibility: SortOrder
  _avg: FlowAvgOrderByAggregateInput
  _count: FlowCountOrderByAggregateInput
  _max: FlowMaxOrderByAggregateInput
  _min: FlowMinOrderByAggregateInput
  _sum: FlowSumOrderByAggregateInput
}

input FlowOrderByWithRelationInput {
  Body: SortOrder
  CreatedTime: SortOrder
  FK_FlashCardStacks: FlashCardStackOrderByRelationAggregateInput
  FK_Tags: FlowTagOnFlowOrderByRelationAggregateInput
  FK_User: UserOrderByWithRelationInput
  FK_UserID: SortOrder
  FlowID: SortOrder
  Title: SortOrder
  Visibility: SortOrder
}

input FlowRelationFilter {
  is: FlowWhereInput
  isNot: FlowWhereInput
}

enum FlowScalarFieldEnum {
  Body
  CreatedTime
  FK_UserID
  FlowID
  Title
  Visibility
}

input FlowScalarWhereInput {
  AND: [FlowScalarWhereInput!]
  Body: StringNullableFilter
  CreatedTime: DateTimeFilter
  FK_UserID: IntNullableFilter
  FlowID: IntFilter
  NOT: [FlowScalarWhereInput!]
  OR: [FlowScalarWhereInput!]
  Title: StringNullableFilter
  Visibility: EnumVisibilityNullableFilter
}

input FlowScalarWhereWithAggregatesInput {
  AND: [FlowScalarWhereWithAggregatesInput!]
  Body: StringNullableWithAggregatesFilter
  CreatedTime: DateTimeWithAggregatesFilter
  FK_UserID: IntNullableWithAggregatesFilter
  FlowID: IntWithAggregatesFilter
  NOT: [FlowScalarWhereWithAggregatesInput!]
  OR: [FlowScalarWhereWithAggregatesInput!]
  Title: StringNullableWithAggregatesFilter
  Visibility: EnumVisibilityNullableWithAggregatesFilter
}

type FlowSumAggregate {
  FK_UserID: Int
  FlowID: Int
}

input FlowSumOrderByAggregateInput {
  FK_UserID: SortOrder
  FlowID: SortOrder
}

type FlowTag {
  CreatedTime: DateTime!
  FK_Flows(cursor: FlowTagOnFlowWhereUniqueInput, distinct: [FlowTagOnFlowScalarFieldEnum!], orderBy: [FlowTagOnFlowOrderByWithRelationInput!], skip: Int, take: Int, where: FlowTagOnFlowWhereInput): [FlowTagOnFlow!]!
  FK_User: User
  FK_UserID: Int
  FlowTagID: Int!
  Name: String!
  Public: Boolean!
  _count: FlowTagCount
}

type FlowTagAvgAggregate {
  FK_UserID: Float
  FlowTagID: Float
}

input FlowTagAvgOrderByAggregateInput {
  FK_UserID: SortOrder
  FlowTagID: SortOrder
}

type FlowTagCount {
  FK_Flows: Int!
}

type FlowTagCountAggregate {
  CreatedTime: Int!
  FK_UserID: Int!
  FlowTagID: Int!
  Name: Int!
  Public: Int!
  _all: Int!
}

input FlowTagCountOrderByAggregateInput {
  CreatedTime: SortOrder
  FK_UserID: SortOrder
  FlowTagID: SortOrder
  Name: SortOrder
  Public: SortOrder
}

input FlowTagCreateInput {
  CreatedTime: DateTime
  FK_Flows: FlowTagOnFlowCreateNestedManyWithoutFK_FlowTagInput
  FK_User: UserCreateNestedOneWithoutFK_FlowTagsInput
  Name: String!
  Public: Boolean
}

input FlowTagCreateManyFK_UserInput {
  CreatedTime: DateTime
  FlowTagID: Int
  Name: String!
  Public: Boolean
}

input FlowTagCreateManyFK_UserInputEnvelope {
  data: [FlowTagCreateManyFK_UserInput!]!
  skipDuplicates: Boolean
}

input FlowTagCreateManyInput {
  CreatedTime: DateTime
  FK_UserID: Int
  FlowTagID: Int
  Name: String!
  Public: Boolean
}

input FlowTagCreateNestedManyWithoutFK_UserInput {
  connect: [FlowTagWhereUniqueInput!]
  connectOrCreate: [FlowTagCreateOrConnectWithoutFK_UserInput!]
  create: [FlowTagCreateWithoutFK_UserInput!]
  createMany: FlowTagCreateManyFK_UserInputEnvelope
}

input FlowTagCreateNestedOneWithoutFK_FlowsInput {
  connect: FlowTagWhereUniqueInput
  connectOrCreate: FlowTagCreateOrConnectWithoutFK_FlowsInput
  create: FlowTagCreateWithoutFK_FlowsInput
}

input FlowTagCreateOrConnectWithoutFK_FlowsInput {
  create: FlowTagCreateWithoutFK_FlowsInput!
  where: FlowTagWhereUniqueInput!
}

input FlowTagCreateOrConnectWithoutFK_UserInput {
  create: FlowTagCreateWithoutFK_UserInput!
  where: FlowTagWhereUniqueInput!
}

input FlowTagCreateWithoutFK_FlowsInput {
  CreatedTime: DateTime
  FK_User: UserCreateNestedOneWithoutFK_FlowTagsInput
  Name: String!
  Public: Boolean
}

input FlowTagCreateWithoutFK_UserInput {
  CreatedTime: DateTime
  FK_Flows: FlowTagOnFlowCreateNestedManyWithoutFK_FlowTagInput
  Name: String!
  Public: Boolean
}

type FlowTagGroupBy {
  CreatedTime: DateTime!
  FK_UserID: Int
  FlowTagID: Int!
  Name: String!
  Public: Boolean!
  _avg: FlowTagAvgAggregate
  _count: FlowTagCountAggregate
  _max: FlowTagMaxAggregate
  _min: FlowTagMinAggregate
  _sum: FlowTagSumAggregate
}

input FlowTagListRelationFilter {
  every: FlowTagWhereInput
  none: FlowTagWhereInput
  some: FlowTagWhereInput
}

type FlowTagMaxAggregate {
  CreatedTime: DateTime
  FK_UserID: Int
  FlowTagID: Int
  Name: String
  Public: Boolean
}

input FlowTagMaxOrderByAggregateInput {
  CreatedTime: SortOrder
  FK_UserID: SortOrder
  FlowTagID: SortOrder
  Name: SortOrder
  Public: SortOrder
}

type FlowTagMinAggregate {
  CreatedTime: DateTime
  FK_UserID: Int
  FlowTagID: Int
  Name: String
  Public: Boolean
}

input FlowTagMinOrderByAggregateInput {
  CreatedTime: SortOrder
  FK_UserID: SortOrder
  FlowTagID: SortOrder
  Name: SortOrder
  Public: SortOrder
}

type FlowTagOnFlow {
  FK_Flow: Flow
  FK_FlowID: Int
  FK_FlowTag: FlowTag
  FK_FlowTagID: Int
  FlowTagOnFlowID: Int!
  HOLDER: String
}

type FlowTagOnFlowAvgAggregate {
  FK_FlowID: Float
  FK_FlowTagID: Float
  FlowTagOnFlowID: Float
}

input FlowTagOnFlowAvgOrderByAggregateInput {
  FK_FlowID: SortOrder
  FK_FlowTagID: SortOrder
  FlowTagOnFlowID: SortOrder
}

type FlowTagOnFlowCountAggregate {
  FK_FlowID: Int!
  FK_FlowTagID: Int!
  FlowTagOnFlowID: Int!
  HOLDER: Int!
  _all: Int!
}

input FlowTagOnFlowCountOrderByAggregateInput {
  FK_FlowID: SortOrder
  FK_FlowTagID: SortOrder
  FlowTagOnFlowID: SortOrder
  HOLDER: SortOrder
}

input FlowTagOnFlowCreateInput {
  FK_Flow: FlowCreateNestedOneWithoutFK_TagsInput
  FK_FlowTag: FlowTagCreateNestedOneWithoutFK_FlowsInput
  HOLDER: String
}

input FlowTagOnFlowCreateManyFK_FlowInput {
  FK_FlowTagID: Int
  FlowTagOnFlowID: Int
  HOLDER: String
}

input FlowTagOnFlowCreateManyFK_FlowInputEnvelope {
  data: [FlowTagOnFlowCreateManyFK_FlowInput!]!
  skipDuplicates: Boolean
}

input FlowTagOnFlowCreateManyFK_FlowTagInput {
  FK_FlowID: Int
  FlowTagOnFlowID: Int
  HOLDER: String
}

input FlowTagOnFlowCreateManyFK_FlowTagInputEnvelope {
  data: [FlowTagOnFlowCreateManyFK_FlowTagInput!]!
  skipDuplicates: Boolean
}

input FlowTagOnFlowCreateManyInput {
  FK_FlowID: Int
  FK_FlowTagID: Int
  FlowTagOnFlowID: Int
  HOLDER: String
}

input FlowTagOnFlowCreateNestedManyWithoutFK_FlowInput {
  connect: [FlowTagOnFlowWhereUniqueInput!]
  connectOrCreate: [FlowTagOnFlowCreateOrConnectWithoutFK_FlowInput!]
  create: [FlowTagOnFlowCreateWithoutFK_FlowInput!]
  createMany: FlowTagOnFlowCreateManyFK_FlowInputEnvelope
}

input FlowTagOnFlowCreateNestedManyWithoutFK_FlowTagInput {
  connect: [FlowTagOnFlowWhereUniqueInput!]
  connectOrCreate: [FlowTagOnFlowCreateOrConnectWithoutFK_FlowTagInput!]
  create: [FlowTagOnFlowCreateWithoutFK_FlowTagInput!]
  createMany: FlowTagOnFlowCreateManyFK_FlowTagInputEnvelope
}

input FlowTagOnFlowCreateOrConnectWithoutFK_FlowInput {
  create: FlowTagOnFlowCreateWithoutFK_FlowInput!
  where: FlowTagOnFlowWhereUniqueInput!
}

input FlowTagOnFlowCreateOrConnectWithoutFK_FlowTagInput {
  create: FlowTagOnFlowCreateWithoutFK_FlowTagInput!
  where: FlowTagOnFlowWhereUniqueInput!
}

input FlowTagOnFlowCreateWithoutFK_FlowInput {
  FK_FlowTag: FlowTagCreateNestedOneWithoutFK_FlowsInput
  HOLDER: String
}

input FlowTagOnFlowCreateWithoutFK_FlowTagInput {
  FK_Flow: FlowCreateNestedOneWithoutFK_TagsInput
  HOLDER: String
}

type FlowTagOnFlowGroupBy {
  FK_FlowID: Int
  FK_FlowTagID: Int
  FlowTagOnFlowID: Int!
  HOLDER: String
  _avg: FlowTagOnFlowAvgAggregate
  _count: FlowTagOnFlowCountAggregate
  _max: FlowTagOnFlowMaxAggregate
  _min: FlowTagOnFlowMinAggregate
  _sum: FlowTagOnFlowSumAggregate
}

input FlowTagOnFlowListRelationFilter {
  every: FlowTagOnFlowWhereInput
  none: FlowTagOnFlowWhereInput
  some: FlowTagOnFlowWhereInput
}

type FlowTagOnFlowMaxAggregate {
  FK_FlowID: Int
  FK_FlowTagID: Int
  FlowTagOnFlowID: Int
  HOLDER: String
}

input FlowTagOnFlowMaxOrderByAggregateInput {
  FK_FlowID: SortOrder
  FK_FlowTagID: SortOrder
  FlowTagOnFlowID: SortOrder
  HOLDER: SortOrder
}

type FlowTagOnFlowMinAggregate {
  FK_FlowID: Int
  FK_FlowTagID: Int
  FlowTagOnFlowID: Int
  HOLDER: String
}

input FlowTagOnFlowMinOrderByAggregateInput {
  FK_FlowID: SortOrder
  FK_FlowTagID: SortOrder
  FlowTagOnFlowID: SortOrder
  HOLDER: SortOrder
}

input FlowTagOnFlowOrderByRelationAggregateInput {
  _count: SortOrder
}

input FlowTagOnFlowOrderByWithAggregationInput {
  FK_FlowID: SortOrder
  FK_FlowTagID: SortOrder
  FlowTagOnFlowID: SortOrder
  HOLDER: SortOrder
  _avg: FlowTagOnFlowAvgOrderByAggregateInput
  _count: FlowTagOnFlowCountOrderByAggregateInput
  _max: FlowTagOnFlowMaxOrderByAggregateInput
  _min: FlowTagOnFlowMinOrderByAggregateInput
  _sum: FlowTagOnFlowSumOrderByAggregateInput
}

input FlowTagOnFlowOrderByWithRelationInput {
  FK_Flow: FlowOrderByWithRelationInput
  FK_FlowID: SortOrder
  FK_FlowTag: FlowTagOrderByWithRelationInput
  FK_FlowTagID: SortOrder
  FlowTagOnFlowID: SortOrder
  HOLDER: SortOrder
}

enum FlowTagOnFlowScalarFieldEnum {
  FK_FlowID
  FK_FlowTagID
  FlowTagOnFlowID
  HOLDER
}

input FlowTagOnFlowScalarWhereInput {
  AND: [FlowTagOnFlowScalarWhereInput!]
  FK_FlowID: IntNullableFilter
  FK_FlowTagID: IntNullableFilter
  FlowTagOnFlowID: IntFilter
  HOLDER: StringNullableFilter
  NOT: [FlowTagOnFlowScalarWhereInput!]
  OR: [FlowTagOnFlowScalarWhereInput!]
}

input FlowTagOnFlowScalarWhereWithAggregatesInput {
  AND: [FlowTagOnFlowScalarWhereWithAggregatesInput!]
  FK_FlowID: IntNullableWithAggregatesFilter
  FK_FlowTagID: IntNullableWithAggregatesFilter
  FlowTagOnFlowID: IntWithAggregatesFilter
  HOLDER: StringNullableWithAggregatesFilter
  NOT: [FlowTagOnFlowScalarWhereWithAggregatesInput!]
  OR: [FlowTagOnFlowScalarWhereWithAggregatesInput!]
}

type FlowTagOnFlowSumAggregate {
  FK_FlowID: Int
  FK_FlowTagID: Int
  FlowTagOnFlowID: Int
}

input FlowTagOnFlowSumOrderByAggregateInput {
  FK_FlowID: SortOrder
  FK_FlowTagID: SortOrder
  FlowTagOnFlowID: SortOrder
}

input FlowTagOnFlowUpdateInput {
  FK_Flow: FlowUpdateOneWithoutFK_TagsInput
  FK_FlowTag: FlowTagUpdateOneWithoutFK_FlowsInput
  HOLDER: NullableStringFieldUpdateOperationsInput
}

input FlowTagOnFlowUpdateManyMutationInput {
  HOLDER: NullableStringFieldUpdateOperationsInput
}

input FlowTagOnFlowUpdateManyWithWhereWithoutFK_FlowInput {
  data: FlowTagOnFlowUpdateManyMutationInput!
  where: FlowTagOnFlowScalarWhereInput!
}

input FlowTagOnFlowUpdateManyWithWhereWithoutFK_FlowTagInput {
  data: FlowTagOnFlowUpdateManyMutationInput!
  where: FlowTagOnFlowScalarWhereInput!
}

input FlowTagOnFlowUpdateManyWithoutFK_FlowInput {
  connect: [FlowTagOnFlowWhereUniqueInput!]
  connectOrCreate: [FlowTagOnFlowCreateOrConnectWithoutFK_FlowInput!]
  create: [FlowTagOnFlowCreateWithoutFK_FlowInput!]
  createMany: FlowTagOnFlowCreateManyFK_FlowInputEnvelope
  delete: [FlowTagOnFlowWhereUniqueInput!]
  deleteMany: [FlowTagOnFlowScalarWhereInput!]
  disconnect: [FlowTagOnFlowWhereUniqueInput!]
  set: [FlowTagOnFlowWhereUniqueInput!]
  update: [FlowTagOnFlowUpdateWithWhereUniqueWithoutFK_FlowInput!]
  updateMany: [FlowTagOnFlowUpdateManyWithWhereWithoutFK_FlowInput!]
  upsert: [FlowTagOnFlowUpsertWithWhereUniqueWithoutFK_FlowInput!]
}

input FlowTagOnFlowUpdateManyWithoutFK_FlowTagInput {
  connect: [FlowTagOnFlowWhereUniqueInput!]
  connectOrCreate: [FlowTagOnFlowCreateOrConnectWithoutFK_FlowTagInput!]
  create: [FlowTagOnFlowCreateWithoutFK_FlowTagInput!]
  createMany: FlowTagOnFlowCreateManyFK_FlowTagInputEnvelope
  delete: [FlowTagOnFlowWhereUniqueInput!]
  deleteMany: [FlowTagOnFlowScalarWhereInput!]
  disconnect: [FlowTagOnFlowWhereUniqueInput!]
  set: [FlowTagOnFlowWhereUniqueInput!]
  update: [FlowTagOnFlowUpdateWithWhereUniqueWithoutFK_FlowTagInput!]
  updateMany: [FlowTagOnFlowUpdateManyWithWhereWithoutFK_FlowTagInput!]
  upsert: [FlowTagOnFlowUpsertWithWhereUniqueWithoutFK_FlowTagInput!]
}

input FlowTagOnFlowUpdateWithWhereUniqueWithoutFK_FlowInput {
  data: FlowTagOnFlowUpdateWithoutFK_FlowInput!
  where: FlowTagOnFlowWhereUniqueInput!
}

input FlowTagOnFlowUpdateWithWhereUniqueWithoutFK_FlowTagInput {
  data: FlowTagOnFlowUpdateWithoutFK_FlowTagInput!
  where: FlowTagOnFlowWhereUniqueInput!
}

input FlowTagOnFlowUpdateWithoutFK_FlowInput {
  FK_FlowTag: FlowTagUpdateOneWithoutFK_FlowsInput
  HOLDER: NullableStringFieldUpdateOperationsInput
}

input FlowTagOnFlowUpdateWithoutFK_FlowTagInput {
  FK_Flow: FlowUpdateOneWithoutFK_TagsInput
  HOLDER: NullableStringFieldUpdateOperationsInput
}

input FlowTagOnFlowUpsertWithWhereUniqueWithoutFK_FlowInput {
  create: FlowTagOnFlowCreateWithoutFK_FlowInput!
  update: FlowTagOnFlowUpdateWithoutFK_FlowInput!
  where: FlowTagOnFlowWhereUniqueInput!
}

input FlowTagOnFlowUpsertWithWhereUniqueWithoutFK_FlowTagInput {
  create: FlowTagOnFlowCreateWithoutFK_FlowTagInput!
  update: FlowTagOnFlowUpdateWithoutFK_FlowTagInput!
  where: FlowTagOnFlowWhereUniqueInput!
}

input FlowTagOnFlowWhereInput {
  AND: [FlowTagOnFlowWhereInput!]
  FK_Flow: FlowRelationFilter
  FK_FlowID: IntNullableFilter
  FK_FlowTag: FlowTagRelationFilter
  FK_FlowTagID: IntNullableFilter
  FlowTagOnFlowID: IntFilter
  HOLDER: StringNullableFilter
  NOT: [FlowTagOnFlowWhereInput!]
  OR: [FlowTagOnFlowWhereInput!]
}

input FlowTagOnFlowWhereUniqueInput {
  FlowTagOnFlowID: Int
}

input FlowTagOrderByRelationAggregateInput {
  _count: SortOrder
}

input FlowTagOrderByWithAggregationInput {
  CreatedTime: SortOrder
  FK_UserID: SortOrder
  FlowTagID: SortOrder
  Name: SortOrder
  Public: SortOrder
  _avg: FlowTagAvgOrderByAggregateInput
  _count: FlowTagCountOrderByAggregateInput
  _max: FlowTagMaxOrderByAggregateInput
  _min: FlowTagMinOrderByAggregateInput
  _sum: FlowTagSumOrderByAggregateInput
}

input FlowTagOrderByWithRelationInput {
  CreatedTime: SortOrder
  FK_Flows: FlowTagOnFlowOrderByRelationAggregateInput
  FK_User: UserOrderByWithRelationInput
  FK_UserID: SortOrder
  FlowTagID: SortOrder
  Name: SortOrder
  Public: SortOrder
}

input FlowTagRelationFilter {
  is: FlowTagWhereInput
  isNot: FlowTagWhereInput
}

enum FlowTagScalarFieldEnum {
  CreatedTime
  FK_UserID
  FlowTagID
  Name
  Public
}

input FlowTagScalarWhereInput {
  AND: [FlowTagScalarWhereInput!]
  CreatedTime: DateTimeFilter
  FK_UserID: IntNullableFilter
  FlowTagID: IntFilter
  NOT: [FlowTagScalarWhereInput!]
  Name: StringFilter
  OR: [FlowTagScalarWhereInput!]
  Public: BoolFilter
}

input FlowTagScalarWhereWithAggregatesInput {
  AND: [FlowTagScalarWhereWithAggregatesInput!]
  CreatedTime: DateTimeWithAggregatesFilter
  FK_UserID: IntNullableWithAggregatesFilter
  FlowTagID: IntWithAggregatesFilter
  NOT: [FlowTagScalarWhereWithAggregatesInput!]
  Name: StringWithAggregatesFilter
  OR: [FlowTagScalarWhereWithAggregatesInput!]
  Public: BoolWithAggregatesFilter
}

type FlowTagSumAggregate {
  FK_UserID: Int
  FlowTagID: Int
}

input FlowTagSumOrderByAggregateInput {
  FK_UserID: SortOrder
  FlowTagID: SortOrder
}

input FlowTagUpdateInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_Flows: FlowTagOnFlowUpdateManyWithoutFK_FlowTagInput
  FK_User: UserUpdateOneWithoutFK_FlowTagsInput
  Name: StringFieldUpdateOperationsInput
  Public: BoolFieldUpdateOperationsInput
}

input FlowTagUpdateManyMutationInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  Name: StringFieldUpdateOperationsInput
  Public: BoolFieldUpdateOperationsInput
}

input FlowTagUpdateManyWithWhereWithoutFK_UserInput {
  data: FlowTagUpdateManyMutationInput!
  where: FlowTagScalarWhereInput!
}

input FlowTagUpdateManyWithoutFK_UserInput {
  connect: [FlowTagWhereUniqueInput!]
  connectOrCreate: [FlowTagCreateOrConnectWithoutFK_UserInput!]
  create: [FlowTagCreateWithoutFK_UserInput!]
  createMany: FlowTagCreateManyFK_UserInputEnvelope
  delete: [FlowTagWhereUniqueInput!]
  deleteMany: [FlowTagScalarWhereInput!]
  disconnect: [FlowTagWhereUniqueInput!]
  set: [FlowTagWhereUniqueInput!]
  update: [FlowTagUpdateWithWhereUniqueWithoutFK_UserInput!]
  updateMany: [FlowTagUpdateManyWithWhereWithoutFK_UserInput!]
  upsert: [FlowTagUpsertWithWhereUniqueWithoutFK_UserInput!]
}

input FlowTagUpdateOneWithoutFK_FlowsInput {
  connect: FlowTagWhereUniqueInput
  connectOrCreate: FlowTagCreateOrConnectWithoutFK_FlowsInput
  create: FlowTagCreateWithoutFK_FlowsInput
  delete: Boolean
  disconnect: Boolean
  update: FlowTagUpdateWithoutFK_FlowsInput
  upsert: FlowTagUpsertWithoutFK_FlowsInput
}

input FlowTagUpdateWithWhereUniqueWithoutFK_UserInput {
  data: FlowTagUpdateWithoutFK_UserInput!
  where: FlowTagWhereUniqueInput!
}

input FlowTagUpdateWithoutFK_FlowsInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_User: UserUpdateOneWithoutFK_FlowTagsInput
  Name: StringFieldUpdateOperationsInput
  Public: BoolFieldUpdateOperationsInput
}

input FlowTagUpdateWithoutFK_UserInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_Flows: FlowTagOnFlowUpdateManyWithoutFK_FlowTagInput
  Name: StringFieldUpdateOperationsInput
  Public: BoolFieldUpdateOperationsInput
}

input FlowTagUpsertWithWhereUniqueWithoutFK_UserInput {
  create: FlowTagCreateWithoutFK_UserInput!
  update: FlowTagUpdateWithoutFK_UserInput!
  where: FlowTagWhereUniqueInput!
}

input FlowTagUpsertWithoutFK_FlowsInput {
  create: FlowTagCreateWithoutFK_FlowsInput!
  update: FlowTagUpdateWithoutFK_FlowsInput!
}

input FlowTagWhereInput {
  AND: [FlowTagWhereInput!]
  CreatedTime: DateTimeFilter
  FK_Flows: FlowTagOnFlowListRelationFilter
  FK_User: UserRelationFilter
  FK_UserID: IntNullableFilter
  FlowTagID: IntFilter
  NOT: [FlowTagWhereInput!]
  Name: StringFilter
  OR: [FlowTagWhereInput!]
  Public: BoolFilter
}

input FlowTagWhereUniqueInput {
  FlowTagID: Int
}

input FlowUpdateInput {
  Body: NullableStringFieldUpdateOperationsInput
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_FlashCardStacks: FlashCardStackUpdateManyWithoutFK_FlowInput
  FK_Tags: FlowTagOnFlowUpdateManyWithoutFK_FlowInput
  FK_User: UserUpdateOneWithoutFK_FlowsInput
  Title: NullableStringFieldUpdateOperationsInput
  Visibility: NullableEnumVisibilityFieldUpdateOperationsInput
}

input FlowUpdateManyMutationInput {
  Body: NullableStringFieldUpdateOperationsInput
  CreatedTime: DateTimeFieldUpdateOperationsInput
  Title: NullableStringFieldUpdateOperationsInput
  Visibility: NullableEnumVisibilityFieldUpdateOperationsInput
}

input FlowUpdateManyWithWhereWithoutFK_UserInput {
  data: FlowUpdateManyMutationInput!
  where: FlowScalarWhereInput!
}

input FlowUpdateManyWithoutFK_UserInput {
  connect: [FlowWhereUniqueInput!]
  connectOrCreate: [FlowCreateOrConnectWithoutFK_UserInput!]
  create: [FlowCreateWithoutFK_UserInput!]
  createMany: FlowCreateManyFK_UserInputEnvelope
  delete: [FlowWhereUniqueInput!]
  deleteMany: [FlowScalarWhereInput!]
  disconnect: [FlowWhereUniqueInput!]
  set: [FlowWhereUniqueInput!]
  update: [FlowUpdateWithWhereUniqueWithoutFK_UserInput!]
  updateMany: [FlowUpdateManyWithWhereWithoutFK_UserInput!]
  upsert: [FlowUpsertWithWhereUniqueWithoutFK_UserInput!]
}

input FlowUpdateOneWithoutFK_FlashCardStacksInput {
  connect: FlowWhereUniqueInput
  connectOrCreate: FlowCreateOrConnectWithoutFK_FlashCardStacksInput
  create: FlowCreateWithoutFK_FlashCardStacksInput
  delete: Boolean
  disconnect: Boolean
  update: FlowUpdateWithoutFK_FlashCardStacksInput
  upsert: FlowUpsertWithoutFK_FlashCardStacksInput
}

input FlowUpdateOneWithoutFK_TagsInput {
  connect: FlowWhereUniqueInput
  connectOrCreate: FlowCreateOrConnectWithoutFK_TagsInput
  create: FlowCreateWithoutFK_TagsInput
  delete: Boolean
  disconnect: Boolean
  update: FlowUpdateWithoutFK_TagsInput
  upsert: FlowUpsertWithoutFK_TagsInput
}

input FlowUpdateWithWhereUniqueWithoutFK_UserInput {
  data: FlowUpdateWithoutFK_UserInput!
  where: FlowWhereUniqueInput!
}

input FlowUpdateWithoutFK_FlashCardStacksInput {
  Body: NullableStringFieldUpdateOperationsInput
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_Tags: FlowTagOnFlowUpdateManyWithoutFK_FlowInput
  FK_User: UserUpdateOneWithoutFK_FlowsInput
  Title: NullableStringFieldUpdateOperationsInput
  Visibility: NullableEnumVisibilityFieldUpdateOperationsInput
}

input FlowUpdateWithoutFK_TagsInput {
  Body: NullableStringFieldUpdateOperationsInput
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_FlashCardStacks: FlashCardStackUpdateManyWithoutFK_FlowInput
  FK_User: UserUpdateOneWithoutFK_FlowsInput
  Title: NullableStringFieldUpdateOperationsInput
  Visibility: NullableEnumVisibilityFieldUpdateOperationsInput
}

input FlowUpdateWithoutFK_UserInput {
  Body: NullableStringFieldUpdateOperationsInput
  CreatedTime: DateTimeFieldUpdateOperationsInput
  FK_FlashCardStacks: FlashCardStackUpdateManyWithoutFK_FlowInput
  FK_Tags: FlowTagOnFlowUpdateManyWithoutFK_FlowInput
  Title: NullableStringFieldUpdateOperationsInput
  Visibility: NullableEnumVisibilityFieldUpdateOperationsInput
}

input FlowUpsertWithWhereUniqueWithoutFK_UserInput {
  create: FlowCreateWithoutFK_UserInput!
  update: FlowUpdateWithoutFK_UserInput!
  where: FlowWhereUniqueInput!
}

input FlowUpsertWithoutFK_FlashCardStacksInput {
  create: FlowCreateWithoutFK_FlashCardStacksInput!
  update: FlowUpdateWithoutFK_FlashCardStacksInput!
}

input FlowUpsertWithoutFK_TagsInput {
  create: FlowCreateWithoutFK_TagsInput!
  update: FlowUpdateWithoutFK_TagsInput!
}

input FlowWhereInput {
  AND: [FlowWhereInput!]
  Body: StringNullableFilter
  CreatedTime: DateTimeFilter
  FK_FlashCardStacks: FlashCardStackListRelationFilter
  FK_Tags: FlowTagOnFlowListRelationFilter
  FK_User: UserRelationFilter
  FK_UserID: IntNullableFilter
  FlowID: IntFilter
  NOT: [FlowWhereInput!]
  OR: [FlowWhereInput!]
  Title: StringNullableFilter
  Visibility: EnumVisibilityNullableFilter
}

input FlowWhereUniqueInput {
  FlowID: Int
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createCourse(data: CourseCreateInput!): Course!
  createCourseOnUser(data: CourseOnUserCreateInput!): CourseOnUser!
  createFlashCard(data: FlashCardCreateInput!): FlashCard!
  createFlashCardStack(data: FlashCardStackCreateInput!): FlashCardStack!
  createFlow(data: FlowCreateInput!): Flow!
  createFlowTag(data: FlowTagCreateInput!): FlowTag!
  createFlowTagOnFlow(data: FlowTagOnFlowCreateInput!): FlowTagOnFlow!
  createManyCourse(data: [CourseCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCourseOnUser(data: [CourseOnUserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyFlashCard(data: [FlashCardCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyFlashCardStack(data: [FlashCardStackCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyFlow(data: [FlowCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyFlowTag(data: [FlowTagCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyFlowTagOnFlow(data: [FlowTagOnFlowCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyProfessor(data: [ProfessorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySchool(data: [SchoolCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createProfessor(data: ProfessorCreateInput!): Professor!
  createSchool(data: SchoolCreateInput!): School!
  createUser(data: UserCreateInput!): User!
  deleteCourse(where: CourseWhereUniqueInput!): Course
  deleteCourseOnUser(where: CourseOnUserWhereUniqueInput!): CourseOnUser
  deleteFlashCard(where: FlashCardWhereUniqueInput!): FlashCard
  deleteFlashCardStack(where: FlashCardStackWhereUniqueInput!): FlashCardStack
  deleteFlow(where: FlowWhereUniqueInput!): Flow
  deleteFlowTag(where: FlowTagWhereUniqueInput!): FlowTag
  deleteFlowTagOnFlow(where: FlowTagOnFlowWhereUniqueInput!): FlowTagOnFlow
  deleteManyCourse(where: CourseWhereInput): AffectedRowsOutput!
  deleteManyCourseOnUser(where: CourseOnUserWhereInput): AffectedRowsOutput!
  deleteManyFlashCard(where: FlashCardWhereInput): AffectedRowsOutput!
  deleteManyFlashCardStack(where: FlashCardStackWhereInput): AffectedRowsOutput!
  deleteManyFlow(where: FlowWhereInput): AffectedRowsOutput!
  deleteManyFlowTag(where: FlowTagWhereInput): AffectedRowsOutput!
  deleteManyFlowTagOnFlow(where: FlowTagOnFlowWhereInput): AffectedRowsOutput!
  deleteManyProfessor(where: ProfessorWhereInput): AffectedRowsOutput!
  deleteManySchool(where: SchoolWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteProfessor(where: ProfessorWhereUniqueInput!): Professor
  deleteSchool(where: SchoolWhereUniqueInput!): School
  deleteUser(where: UserWhereUniqueInput!): User
  updateCourse(data: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course
  updateCourseOnUser(data: CourseOnUserUpdateInput!, where: CourseOnUserWhereUniqueInput!): CourseOnUser
  updateFlashCard(data: FlashCardUpdateInput!, where: FlashCardWhereUniqueInput!): FlashCard
  updateFlashCardStack(data: FlashCardStackUpdateInput!, where: FlashCardStackWhereUniqueInput!): FlashCardStack
  updateFlow(data: FlowUpdateInput!, where: FlowWhereUniqueInput!): Flow
  updateFlowTag(data: FlowTagUpdateInput!, where: FlowTagWhereUniqueInput!): FlowTag
  updateFlowTagOnFlow(data: FlowTagOnFlowUpdateInput!, where: FlowTagOnFlowWhereUniqueInput!): FlowTagOnFlow
  updateManyCourse(data: CourseUpdateManyMutationInput!, where: CourseWhereInput): AffectedRowsOutput!
  updateManyCourseOnUser(data: CourseOnUserUpdateManyMutationInput!, where: CourseOnUserWhereInput): AffectedRowsOutput!
  updateManyFlashCard(data: FlashCardUpdateManyMutationInput!, where: FlashCardWhereInput): AffectedRowsOutput!
  updateManyFlashCardStack(data: FlashCardStackUpdateManyMutationInput!, where: FlashCardStackWhereInput): AffectedRowsOutput!
  updateManyFlow(data: FlowUpdateManyMutationInput!, where: FlowWhereInput): AffectedRowsOutput!
  updateManyFlowTag(data: FlowTagUpdateManyMutationInput!, where: FlowTagWhereInput): AffectedRowsOutput!
  updateManyFlowTagOnFlow(data: FlowTagOnFlowUpdateManyMutationInput!, where: FlowTagOnFlowWhereInput): AffectedRowsOutput!
  updateManyProfessor(data: ProfessorUpdateManyMutationInput!, where: ProfessorWhereInput): AffectedRowsOutput!
  updateManySchool(data: SchoolUpdateManyMutationInput!, where: SchoolWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateProfessor(data: ProfessorUpdateInput!, where: ProfessorWhereUniqueInput!): Professor
  updateSchool(data: SchoolUpdateInput!, where: SchoolWhereUniqueInput!): School
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertCourse(create: CourseCreateInput!, update: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course!
  upsertCourseOnUser(create: CourseOnUserCreateInput!, update: CourseOnUserUpdateInput!, where: CourseOnUserWhereUniqueInput!): CourseOnUser!
  upsertFlashCard(create: FlashCardCreateInput!, update: FlashCardUpdateInput!, where: FlashCardWhereUniqueInput!): FlashCard!
  upsertFlashCardStack(create: FlashCardStackCreateInput!, update: FlashCardStackUpdateInput!, where: FlashCardStackWhereUniqueInput!): FlashCardStack!
  upsertFlow(create: FlowCreateInput!, update: FlowUpdateInput!, where: FlowWhereUniqueInput!): Flow!
  upsertFlowTag(create: FlowTagCreateInput!, update: FlowTagUpdateInput!, where: FlowTagWhereUniqueInput!): FlowTag!
  upsertFlowTagOnFlow(create: FlowTagOnFlowCreateInput!, update: FlowTagOnFlowUpdateInput!, where: FlowTagOnFlowWhereUniqueInput!): FlowTagOnFlow!
  upsertProfessor(create: ProfessorCreateInput!, update: ProfessorUpdateInput!, where: ProfessorWhereUniqueInput!): Professor!
  upsertSchool(create: SchoolCreateInput!, update: SchoolUpdateInput!, where: SchoolWhereUniqueInput!): School!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumVisibilityNullableFilter {
  equals: Visibility
  in: [Visibility!]
  not: NestedEnumVisibilityNullableFilter
  notIn: [Visibility!]
}

input NestedEnumVisibilityNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedEnumVisibilityNullableFilter
  _min: NestedEnumVisibilityNullableFilter
  equals: Visibility
  in: [Visibility!]
  not: NestedEnumVisibilityNullableWithAggregatesFilter
  notIn: [Visibility!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableEnumVisibilityFieldUpdateOperationsInput {
  set: Visibility
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Professor {
  FK_Course: Course
  FK_CourseID: Int
  Name: String!
  ProfessorID: Int!
}

type ProfessorAvgAggregate {
  FK_CourseID: Float
  ProfessorID: Float
}

input ProfessorAvgOrderByAggregateInput {
  FK_CourseID: SortOrder
  ProfessorID: SortOrder
}

type ProfessorCountAggregate {
  FK_CourseID: Int!
  Name: Int!
  ProfessorID: Int!
  _all: Int!
}

input ProfessorCountOrderByAggregateInput {
  FK_CourseID: SortOrder
  Name: SortOrder
  ProfessorID: SortOrder
}

input ProfessorCreateInput {
  FK_Course: CourseCreateNestedOneWithoutFK_ProfessorsInput
  Name: String!
}

input ProfessorCreateManyFK_CourseInput {
  Name: String!
  ProfessorID: Int
}

input ProfessorCreateManyFK_CourseInputEnvelope {
  data: [ProfessorCreateManyFK_CourseInput!]!
  skipDuplicates: Boolean
}

input ProfessorCreateManyInput {
  FK_CourseID: Int
  Name: String!
  ProfessorID: Int
}

input ProfessorCreateNestedManyWithoutFK_CourseInput {
  connect: [ProfessorWhereUniqueInput!]
  connectOrCreate: [ProfessorCreateOrConnectWithoutFK_CourseInput!]
  create: [ProfessorCreateWithoutFK_CourseInput!]
  createMany: ProfessorCreateManyFK_CourseInputEnvelope
}

input ProfessorCreateOrConnectWithoutFK_CourseInput {
  create: ProfessorCreateWithoutFK_CourseInput!
  where: ProfessorWhereUniqueInput!
}

input ProfessorCreateWithoutFK_CourseInput {
  Name: String!
}

type ProfessorGroupBy {
  FK_CourseID: Int
  Name: String!
  ProfessorID: Int!
  _avg: ProfessorAvgAggregate
  _count: ProfessorCountAggregate
  _max: ProfessorMaxAggregate
  _min: ProfessorMinAggregate
  _sum: ProfessorSumAggregate
}

input ProfessorListRelationFilter {
  every: ProfessorWhereInput
  none: ProfessorWhereInput
  some: ProfessorWhereInput
}

type ProfessorMaxAggregate {
  FK_CourseID: Int
  Name: String
  ProfessorID: Int
}

input ProfessorMaxOrderByAggregateInput {
  FK_CourseID: SortOrder
  Name: SortOrder
  ProfessorID: SortOrder
}

type ProfessorMinAggregate {
  FK_CourseID: Int
  Name: String
  ProfessorID: Int
}

input ProfessorMinOrderByAggregateInput {
  FK_CourseID: SortOrder
  Name: SortOrder
  ProfessorID: SortOrder
}

input ProfessorOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProfessorOrderByWithAggregationInput {
  FK_CourseID: SortOrder
  Name: SortOrder
  ProfessorID: SortOrder
  _avg: ProfessorAvgOrderByAggregateInput
  _count: ProfessorCountOrderByAggregateInput
  _max: ProfessorMaxOrderByAggregateInput
  _min: ProfessorMinOrderByAggregateInput
  _sum: ProfessorSumOrderByAggregateInput
}

input ProfessorOrderByWithRelationInput {
  FK_Course: CourseOrderByWithRelationInput
  FK_CourseID: SortOrder
  Name: SortOrder
  ProfessorID: SortOrder
}

enum ProfessorScalarFieldEnum {
  FK_CourseID
  Name
  ProfessorID
}

input ProfessorScalarWhereInput {
  AND: [ProfessorScalarWhereInput!]
  FK_CourseID: IntNullableFilter
  NOT: [ProfessorScalarWhereInput!]
  Name: StringFilter
  OR: [ProfessorScalarWhereInput!]
  ProfessorID: IntFilter
}

input ProfessorScalarWhereWithAggregatesInput {
  AND: [ProfessorScalarWhereWithAggregatesInput!]
  FK_CourseID: IntNullableWithAggregatesFilter
  NOT: [ProfessorScalarWhereWithAggregatesInput!]
  Name: StringWithAggregatesFilter
  OR: [ProfessorScalarWhereWithAggregatesInput!]
  ProfessorID: IntWithAggregatesFilter
}

type ProfessorSumAggregate {
  FK_CourseID: Int
  ProfessorID: Int
}

input ProfessorSumOrderByAggregateInput {
  FK_CourseID: SortOrder
  ProfessorID: SortOrder
}

input ProfessorUpdateInput {
  FK_Course: CourseUpdateOneWithoutFK_ProfessorsInput
  Name: StringFieldUpdateOperationsInput
}

input ProfessorUpdateManyMutationInput {
  Name: StringFieldUpdateOperationsInput
}

input ProfessorUpdateManyWithWhereWithoutFK_CourseInput {
  data: ProfessorUpdateManyMutationInput!
  where: ProfessorScalarWhereInput!
}

input ProfessorUpdateManyWithoutFK_CourseInput {
  connect: [ProfessorWhereUniqueInput!]
  connectOrCreate: [ProfessorCreateOrConnectWithoutFK_CourseInput!]
  create: [ProfessorCreateWithoutFK_CourseInput!]
  createMany: ProfessorCreateManyFK_CourseInputEnvelope
  delete: [ProfessorWhereUniqueInput!]
  deleteMany: [ProfessorScalarWhereInput!]
  disconnect: [ProfessorWhereUniqueInput!]
  set: [ProfessorWhereUniqueInput!]
  update: [ProfessorUpdateWithWhereUniqueWithoutFK_CourseInput!]
  updateMany: [ProfessorUpdateManyWithWhereWithoutFK_CourseInput!]
  upsert: [ProfessorUpsertWithWhereUniqueWithoutFK_CourseInput!]
}

input ProfessorUpdateWithWhereUniqueWithoutFK_CourseInput {
  data: ProfessorUpdateWithoutFK_CourseInput!
  where: ProfessorWhereUniqueInput!
}

input ProfessorUpdateWithoutFK_CourseInput {
  Name: StringFieldUpdateOperationsInput
}

input ProfessorUpsertWithWhereUniqueWithoutFK_CourseInput {
  create: ProfessorCreateWithoutFK_CourseInput!
  update: ProfessorUpdateWithoutFK_CourseInput!
  where: ProfessorWhereUniqueInput!
}

input ProfessorWhereInput {
  AND: [ProfessorWhereInput!]
  FK_Course: CourseRelationFilter
  FK_CourseID: IntNullableFilter
  NOT: [ProfessorWhereInput!]
  Name: StringFilter
  OR: [ProfessorWhereInput!]
  ProfessorID: IntFilter
}

input ProfessorWhereUniqueInput {
  ProfessorID: Int
}

type Query {
  aggregateCourse(cursor: CourseWhereUniqueInput, orderBy: [CourseOrderByWithRelationInput!], skip: Int, take: Int, where: CourseWhereInput): AggregateCourse!
  aggregateCourseOnUser(cursor: CourseOnUserWhereUniqueInput, orderBy: [CourseOnUserOrderByWithRelationInput!], skip: Int, take: Int, where: CourseOnUserWhereInput): AggregateCourseOnUser!
  aggregateFlashCard(cursor: FlashCardWhereUniqueInput, orderBy: [FlashCardOrderByWithRelationInput!], skip: Int, take: Int, where: FlashCardWhereInput): AggregateFlashCard!
  aggregateFlashCardStack(cursor: FlashCardStackWhereUniqueInput, orderBy: [FlashCardStackOrderByWithRelationInput!], skip: Int, take: Int, where: FlashCardStackWhereInput): AggregateFlashCardStack!
  aggregateFlow(cursor: FlowWhereUniqueInput, orderBy: [FlowOrderByWithRelationInput!], skip: Int, take: Int, where: FlowWhereInput): AggregateFlow!
  aggregateFlowTag(cursor: FlowTagWhereUniqueInput, orderBy: [FlowTagOrderByWithRelationInput!], skip: Int, take: Int, where: FlowTagWhereInput): AggregateFlowTag!
  aggregateFlowTagOnFlow(cursor: FlowTagOnFlowWhereUniqueInput, orderBy: [FlowTagOnFlowOrderByWithRelationInput!], skip: Int, take: Int, where: FlowTagOnFlowWhereInput): AggregateFlowTagOnFlow!
  aggregateProfessor(cursor: ProfessorWhereUniqueInput, orderBy: [ProfessorOrderByWithRelationInput!], skip: Int, take: Int, where: ProfessorWhereInput): AggregateProfessor!
  aggregateSchool(cursor: SchoolWhereUniqueInput, orderBy: [SchoolOrderByWithRelationInput!], skip: Int, take: Int, where: SchoolWhereInput): AggregateSchool!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  course(where: CourseWhereUniqueInput!): Course
  courseOnUser(where: CourseOnUserWhereUniqueInput!): CourseOnUser
  courseOnUsers(cursor: CourseOnUserWhereUniqueInput, distinct: [CourseOnUserScalarFieldEnum!], orderBy: [CourseOnUserOrderByWithRelationInput!], skip: Int, take: Int, where: CourseOnUserWhereInput): [CourseOnUser!]!
  courses(cursor: CourseWhereUniqueInput, distinct: [CourseScalarFieldEnum!], orderBy: [CourseOrderByWithRelationInput!], skip: Int, take: Int, where: CourseWhereInput): [Course!]!
  findFirstCourse(cursor: CourseWhereUniqueInput, distinct: [CourseScalarFieldEnum!], orderBy: [CourseOrderByWithRelationInput!], skip: Int, take: Int, where: CourseWhereInput): Course
  findFirstCourseOnUser(cursor: CourseOnUserWhereUniqueInput, distinct: [CourseOnUserScalarFieldEnum!], orderBy: [CourseOnUserOrderByWithRelationInput!], skip: Int, take: Int, where: CourseOnUserWhereInput): CourseOnUser
  findFirstFlashCard(cursor: FlashCardWhereUniqueInput, distinct: [FlashCardScalarFieldEnum!], orderBy: [FlashCardOrderByWithRelationInput!], skip: Int, take: Int, where: FlashCardWhereInput): FlashCard
  findFirstFlashCardStack(cursor: FlashCardStackWhereUniqueInput, distinct: [FlashCardStackScalarFieldEnum!], orderBy: [FlashCardStackOrderByWithRelationInput!], skip: Int, take: Int, where: FlashCardStackWhereInput): FlashCardStack
  findFirstFlow(cursor: FlowWhereUniqueInput, distinct: [FlowScalarFieldEnum!], orderBy: [FlowOrderByWithRelationInput!], skip: Int, take: Int, where: FlowWhereInput): Flow
  findFirstFlowTag(cursor: FlowTagWhereUniqueInput, distinct: [FlowTagScalarFieldEnum!], orderBy: [FlowTagOrderByWithRelationInput!], skip: Int, take: Int, where: FlowTagWhereInput): FlowTag
  findFirstFlowTagOnFlow(cursor: FlowTagOnFlowWhereUniqueInput, distinct: [FlowTagOnFlowScalarFieldEnum!], orderBy: [FlowTagOnFlowOrderByWithRelationInput!], skip: Int, take: Int, where: FlowTagOnFlowWhereInput): FlowTagOnFlow
  findFirstProfessor(cursor: ProfessorWhereUniqueInput, distinct: [ProfessorScalarFieldEnum!], orderBy: [ProfessorOrderByWithRelationInput!], skip: Int, take: Int, where: ProfessorWhereInput): Professor
  findFirstSchool(cursor: SchoolWhereUniqueInput, distinct: [SchoolScalarFieldEnum!], orderBy: [SchoolOrderByWithRelationInput!], skip: Int, take: Int, where: SchoolWhereInput): School
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  flashCard(where: FlashCardWhereUniqueInput!): FlashCard
  flashCardStack(where: FlashCardStackWhereUniqueInput!): FlashCardStack
  flashCardStacks(cursor: FlashCardStackWhereUniqueInput, distinct: [FlashCardStackScalarFieldEnum!], orderBy: [FlashCardStackOrderByWithRelationInput!], skip: Int, take: Int, where: FlashCardStackWhereInput): [FlashCardStack!]!
  flashCards(cursor: FlashCardWhereUniqueInput, distinct: [FlashCardScalarFieldEnum!], orderBy: [FlashCardOrderByWithRelationInput!], skip: Int, take: Int, where: FlashCardWhereInput): [FlashCard!]!
  flow(where: FlowWhereUniqueInput!): Flow
  flowTag(where: FlowTagWhereUniqueInput!): FlowTag
  flowTagOnFlow(where: FlowTagOnFlowWhereUniqueInput!): FlowTagOnFlow
  flowTagOnFlows(cursor: FlowTagOnFlowWhereUniqueInput, distinct: [FlowTagOnFlowScalarFieldEnum!], orderBy: [FlowTagOnFlowOrderByWithRelationInput!], skip: Int, take: Int, where: FlowTagOnFlowWhereInput): [FlowTagOnFlow!]!
  flowTags(cursor: FlowTagWhereUniqueInput, distinct: [FlowTagScalarFieldEnum!], orderBy: [FlowTagOrderByWithRelationInput!], skip: Int, take: Int, where: FlowTagWhereInput): [FlowTag!]!
  flows(cursor: FlowWhereUniqueInput, distinct: [FlowScalarFieldEnum!], orderBy: [FlowOrderByWithRelationInput!], skip: Int, take: Int, where: FlowWhereInput): [Flow!]!
  groupByCourse(by: [CourseScalarFieldEnum!]!, having: CourseScalarWhereWithAggregatesInput, orderBy: [CourseOrderByWithAggregationInput!], skip: Int, take: Int, where: CourseWhereInput): [CourseGroupBy!]!
  groupByCourseOnUser(by: [CourseOnUserScalarFieldEnum!]!, having: CourseOnUserScalarWhereWithAggregatesInput, orderBy: [CourseOnUserOrderByWithAggregationInput!], skip: Int, take: Int, where: CourseOnUserWhereInput): [CourseOnUserGroupBy!]!
  groupByFlashCard(by: [FlashCardScalarFieldEnum!]!, having: FlashCardScalarWhereWithAggregatesInput, orderBy: [FlashCardOrderByWithAggregationInput!], skip: Int, take: Int, where: FlashCardWhereInput): [FlashCardGroupBy!]!
  groupByFlashCardStack(by: [FlashCardStackScalarFieldEnum!]!, having: FlashCardStackScalarWhereWithAggregatesInput, orderBy: [FlashCardStackOrderByWithAggregationInput!], skip: Int, take: Int, where: FlashCardStackWhereInput): [FlashCardStackGroupBy!]!
  groupByFlow(by: [FlowScalarFieldEnum!]!, having: FlowScalarWhereWithAggregatesInput, orderBy: [FlowOrderByWithAggregationInput!], skip: Int, take: Int, where: FlowWhereInput): [FlowGroupBy!]!
  groupByFlowTag(by: [FlowTagScalarFieldEnum!]!, having: FlowTagScalarWhereWithAggregatesInput, orderBy: [FlowTagOrderByWithAggregationInput!], skip: Int, take: Int, where: FlowTagWhereInput): [FlowTagGroupBy!]!
  groupByFlowTagOnFlow(by: [FlowTagOnFlowScalarFieldEnum!]!, having: FlowTagOnFlowScalarWhereWithAggregatesInput, orderBy: [FlowTagOnFlowOrderByWithAggregationInput!], skip: Int, take: Int, where: FlowTagOnFlowWhereInput): [FlowTagOnFlowGroupBy!]!
  groupByProfessor(by: [ProfessorScalarFieldEnum!]!, having: ProfessorScalarWhereWithAggregatesInput, orderBy: [ProfessorOrderByWithAggregationInput!], skip: Int, take: Int, where: ProfessorWhereInput): [ProfessorGroupBy!]!
  groupBySchool(by: [SchoolScalarFieldEnum!]!, having: SchoolScalarWhereWithAggregatesInput, orderBy: [SchoolOrderByWithAggregationInput!], skip: Int, take: Int, where: SchoolWhereInput): [SchoolGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  professor(where: ProfessorWhereUniqueInput!): Professor
  professors(cursor: ProfessorWhereUniqueInput, distinct: [ProfessorScalarFieldEnum!], orderBy: [ProfessorOrderByWithRelationInput!], skip: Int, take: Int, where: ProfessorWhereInput): [Professor!]!
  school(where: SchoolWhereUniqueInput!): School
  schools(cursor: SchoolWhereUniqueInput, distinct: [SchoolScalarFieldEnum!], orderBy: [SchoolOrderByWithRelationInput!], skip: Int, take: Int, where: SchoolWhereInput): [School!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type School {
  FK_Course(cursor: CourseWhereUniqueInput, distinct: [CourseScalarFieldEnum!], orderBy: [CourseOrderByWithRelationInput!], skip: Int, take: Int, where: CourseWhereInput): [Course!]!
  HasClassSupport: Boolean!
  Name: String!
  SchoolID: Int!
  _count: SchoolCount
}

type SchoolAvgAggregate {
  SchoolID: Float
}

input SchoolAvgOrderByAggregateInput {
  SchoolID: SortOrder
}

type SchoolCount {
  FK_Course: Int!
}

type SchoolCountAggregate {
  HasClassSupport: Int!
  Name: Int!
  SchoolID: Int!
  _all: Int!
}

input SchoolCountOrderByAggregateInput {
  HasClassSupport: SortOrder
  Name: SortOrder
  SchoolID: SortOrder
}

input SchoolCreateInput {
  FK_Course: CourseCreateNestedManyWithoutFK_SchoolInput
  HasClassSupport: Boolean!
  Name: String!
}

input SchoolCreateManyInput {
  HasClassSupport: Boolean!
  Name: String!
  SchoolID: Int
}

input SchoolCreateNestedOneWithoutFK_CourseInput {
  connect: SchoolWhereUniqueInput
  connectOrCreate: SchoolCreateOrConnectWithoutFK_CourseInput
  create: SchoolCreateWithoutFK_CourseInput
}

input SchoolCreateOrConnectWithoutFK_CourseInput {
  create: SchoolCreateWithoutFK_CourseInput!
  where: SchoolWhereUniqueInput!
}

input SchoolCreateWithoutFK_CourseInput {
  HasClassSupport: Boolean!
  Name: String!
}

type SchoolGroupBy {
  HasClassSupport: Boolean!
  Name: String!
  SchoolID: Int!
  _avg: SchoolAvgAggregate
  _count: SchoolCountAggregate
  _max: SchoolMaxAggregate
  _min: SchoolMinAggregate
  _sum: SchoolSumAggregate
}

type SchoolMaxAggregate {
  HasClassSupport: Boolean
  Name: String
  SchoolID: Int
}

input SchoolMaxOrderByAggregateInput {
  HasClassSupport: SortOrder
  Name: SortOrder
  SchoolID: SortOrder
}

type SchoolMinAggregate {
  HasClassSupport: Boolean
  Name: String
  SchoolID: Int
}

input SchoolMinOrderByAggregateInput {
  HasClassSupport: SortOrder
  Name: SortOrder
  SchoolID: SortOrder
}

input SchoolOrderByWithAggregationInput {
  HasClassSupport: SortOrder
  Name: SortOrder
  SchoolID: SortOrder
  _avg: SchoolAvgOrderByAggregateInput
  _count: SchoolCountOrderByAggregateInput
  _max: SchoolMaxOrderByAggregateInput
  _min: SchoolMinOrderByAggregateInput
  _sum: SchoolSumOrderByAggregateInput
}

input SchoolOrderByWithRelationInput {
  FK_Course: CourseOrderByRelationAggregateInput
  HasClassSupport: SortOrder
  Name: SortOrder
  SchoolID: SortOrder
}

input SchoolRelationFilter {
  is: SchoolWhereInput
  isNot: SchoolWhereInput
}

enum SchoolScalarFieldEnum {
  HasClassSupport
  Name
  SchoolID
}

input SchoolScalarWhereWithAggregatesInput {
  AND: [SchoolScalarWhereWithAggregatesInput!]
  HasClassSupport: BoolWithAggregatesFilter
  NOT: [SchoolScalarWhereWithAggregatesInput!]
  Name: StringWithAggregatesFilter
  OR: [SchoolScalarWhereWithAggregatesInput!]
  SchoolID: IntWithAggregatesFilter
}

type SchoolSumAggregate {
  SchoolID: Int
}

input SchoolSumOrderByAggregateInput {
  SchoolID: SortOrder
}

input SchoolUpdateInput {
  FK_Course: CourseUpdateManyWithoutFK_SchoolInput
  HasClassSupport: BoolFieldUpdateOperationsInput
  Name: StringFieldUpdateOperationsInput
}

input SchoolUpdateManyMutationInput {
  HasClassSupport: BoolFieldUpdateOperationsInput
  Name: StringFieldUpdateOperationsInput
}

input SchoolUpdateOneWithoutFK_CourseInput {
  connect: SchoolWhereUniqueInput
  connectOrCreate: SchoolCreateOrConnectWithoutFK_CourseInput
  create: SchoolCreateWithoutFK_CourseInput
  delete: Boolean
  disconnect: Boolean
  update: SchoolUpdateWithoutFK_CourseInput
  upsert: SchoolUpsertWithoutFK_CourseInput
}

input SchoolUpdateWithoutFK_CourseInput {
  HasClassSupport: BoolFieldUpdateOperationsInput
  Name: StringFieldUpdateOperationsInput
}

input SchoolUpsertWithoutFK_CourseInput {
  create: SchoolCreateWithoutFK_CourseInput!
  update: SchoolUpdateWithoutFK_CourseInput!
}

input SchoolWhereInput {
  AND: [SchoolWhereInput!]
  FK_Course: CourseListRelationFilter
  HasClassSupport: BoolFilter
  NOT: [SchoolWhereInput!]
  Name: StringFilter
  OR: [SchoolWhereInput!]
  SchoolID: IntFilter
}

input SchoolWhereUniqueInput {
  SchoolID: Int
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  CreatedTime: DateTime!
  DefaultVisibility: Visibility
  DisplayName: String
  Email: String!
  FK_Courses(cursor: CourseOnUserWhereUniqueInput, distinct: [CourseOnUserScalarFieldEnum!], orderBy: [CourseOnUserOrderByWithRelationInput!], skip: Int, take: Int, where: CourseOnUserWhereInput): [CourseOnUser!]!
  FK_FlashCardStacks(cursor: FlashCardStackWhereUniqueInput, distinct: [FlashCardStackScalarFieldEnum!], orderBy: [FlashCardStackOrderByWithRelationInput!], skip: Int, take: Int, where: FlashCardStackWhereInput): [FlashCardStack!]!
  FK_FlowTags(cursor: FlowTagWhereUniqueInput, distinct: [FlowTagScalarFieldEnum!], orderBy: [FlowTagOrderByWithRelationInput!], skip: Int, take: Int, where: FlowTagWhereInput): [FlowTag!]!
  FK_Flows(cursor: FlowWhereUniqueInput, distinct: [FlowScalarFieldEnum!], orderBy: [FlowOrderByWithRelationInput!], skip: Int, take: Int, where: FlowWhereInput): [Flow!]!
  ProfilePictureLink: String
  UID: String
  UserID: Int!
  _count: UserCount
}

type UserAvgAggregate {
  UserID: Float
}

input UserAvgOrderByAggregateInput {
  UserID: SortOrder
}

type UserCount {
  FK_Courses: Int!
  FK_FlashCardStacks: Int!
  FK_FlowTags: Int!
  FK_Flows: Int!
}

type UserCountAggregate {
  CreatedTime: Int!
  DefaultVisibility: Int!
  DisplayName: Int!
  Email: Int!
  ProfilePictureLink: Int!
  UID: Int!
  UserID: Int!
  _all: Int!
}

input UserCountOrderByAggregateInput {
  CreatedTime: SortOrder
  DefaultVisibility: SortOrder
  DisplayName: SortOrder
  Email: SortOrder
  ProfilePictureLink: SortOrder
  UID: SortOrder
  UserID: SortOrder
}

input UserCreateInput {
  CreatedTime: DateTime
  DefaultVisibility: Visibility
  DisplayName: String
  Email: String!
  FK_Courses: CourseOnUserCreateNestedManyWithoutFK_UserInput
  FK_FlashCardStacks: FlashCardStackCreateNestedManyWithoutFK_UserInput
  FK_FlowTags: FlowTagCreateNestedManyWithoutFK_UserInput
  FK_Flows: FlowCreateNestedManyWithoutFK_UserInput
  ProfilePictureLink: String
  UID: String
}

input UserCreateManyInput {
  CreatedTime: DateTime
  DefaultVisibility: Visibility
  DisplayName: String
  Email: String!
  ProfilePictureLink: String
  UID: String
  UserID: Int
}

input UserCreateNestedOneWithoutFK_CoursesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutFK_CoursesInput
  create: UserCreateWithoutFK_CoursesInput
}

input UserCreateNestedOneWithoutFK_FlashCardStacksInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutFK_FlashCardStacksInput
  create: UserCreateWithoutFK_FlashCardStacksInput
}

input UserCreateNestedOneWithoutFK_FlowTagsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutFK_FlowTagsInput
  create: UserCreateWithoutFK_FlowTagsInput
}

input UserCreateNestedOneWithoutFK_FlowsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutFK_FlowsInput
  create: UserCreateWithoutFK_FlowsInput
}

input UserCreateOrConnectWithoutFK_CoursesInput {
  create: UserCreateWithoutFK_CoursesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutFK_FlashCardStacksInput {
  create: UserCreateWithoutFK_FlashCardStacksInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutFK_FlowTagsInput {
  create: UserCreateWithoutFK_FlowTagsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutFK_FlowsInput {
  create: UserCreateWithoutFK_FlowsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutFK_CoursesInput {
  CreatedTime: DateTime
  DefaultVisibility: Visibility
  DisplayName: String
  Email: String!
  FK_FlashCardStacks: FlashCardStackCreateNestedManyWithoutFK_UserInput
  FK_FlowTags: FlowTagCreateNestedManyWithoutFK_UserInput
  FK_Flows: FlowCreateNestedManyWithoutFK_UserInput
  ProfilePictureLink: String
  UID: String
}

input UserCreateWithoutFK_FlashCardStacksInput {
  CreatedTime: DateTime
  DefaultVisibility: Visibility
  DisplayName: String
  Email: String!
  FK_Courses: CourseOnUserCreateNestedManyWithoutFK_UserInput
  FK_FlowTags: FlowTagCreateNestedManyWithoutFK_UserInput
  FK_Flows: FlowCreateNestedManyWithoutFK_UserInput
  ProfilePictureLink: String
  UID: String
}

input UserCreateWithoutFK_FlowTagsInput {
  CreatedTime: DateTime
  DefaultVisibility: Visibility
  DisplayName: String
  Email: String!
  FK_Courses: CourseOnUserCreateNestedManyWithoutFK_UserInput
  FK_FlashCardStacks: FlashCardStackCreateNestedManyWithoutFK_UserInput
  FK_Flows: FlowCreateNestedManyWithoutFK_UserInput
  ProfilePictureLink: String
  UID: String
}

input UserCreateWithoutFK_FlowsInput {
  CreatedTime: DateTime
  DefaultVisibility: Visibility
  DisplayName: String
  Email: String!
  FK_Courses: CourseOnUserCreateNestedManyWithoutFK_UserInput
  FK_FlashCardStacks: FlashCardStackCreateNestedManyWithoutFK_UserInput
  FK_FlowTags: FlowTagCreateNestedManyWithoutFK_UserInput
  ProfilePictureLink: String
  UID: String
}

type UserGroupBy {
  CreatedTime: DateTime!
  DefaultVisibility: Visibility
  DisplayName: String
  Email: String!
  ProfilePictureLink: String
  UID: String
  UserID: Int!
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

type UserMaxAggregate {
  CreatedTime: DateTime
  DefaultVisibility: Visibility
  DisplayName: String
  Email: String
  ProfilePictureLink: String
  UID: String
  UserID: Int
}

input UserMaxOrderByAggregateInput {
  CreatedTime: SortOrder
  DefaultVisibility: SortOrder
  DisplayName: SortOrder
  Email: SortOrder
  ProfilePictureLink: SortOrder
  UID: SortOrder
  UserID: SortOrder
}

type UserMinAggregate {
  CreatedTime: DateTime
  DefaultVisibility: Visibility
  DisplayName: String
  Email: String
  ProfilePictureLink: String
  UID: String
  UserID: Int
}

input UserMinOrderByAggregateInput {
  CreatedTime: SortOrder
  DefaultVisibility: SortOrder
  DisplayName: SortOrder
  Email: SortOrder
  ProfilePictureLink: SortOrder
  UID: SortOrder
  UserID: SortOrder
}

input UserOrderByWithAggregationInput {
  CreatedTime: SortOrder
  DefaultVisibility: SortOrder
  DisplayName: SortOrder
  Email: SortOrder
  ProfilePictureLink: SortOrder
  UID: SortOrder
  UserID: SortOrder
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
}

input UserOrderByWithRelationInput {
  CreatedTime: SortOrder
  DefaultVisibility: SortOrder
  DisplayName: SortOrder
  Email: SortOrder
  FK_Courses: CourseOnUserOrderByRelationAggregateInput
  FK_FlashCardStacks: FlashCardStackOrderByRelationAggregateInput
  FK_FlowTags: FlowTagOrderByRelationAggregateInput
  FK_Flows: FlowOrderByRelationAggregateInput
  ProfilePictureLink: SortOrder
  UID: SortOrder
  UserID: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  CreatedTime
  DefaultVisibility
  DisplayName
  Email
  ProfilePictureLink
  UID
  UserID
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  CreatedTime: DateTimeWithAggregatesFilter
  DefaultVisibility: EnumVisibilityNullableWithAggregatesFilter
  DisplayName: StringNullableWithAggregatesFilter
  Email: StringWithAggregatesFilter
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  ProfilePictureLink: StringNullableWithAggregatesFilter
  UID: StringNullableWithAggregatesFilter
  UserID: IntWithAggregatesFilter
}

type UserSumAggregate {
  UserID: Int
}

input UserSumOrderByAggregateInput {
  UserID: SortOrder
}

input UserUpdateInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  DefaultVisibility: NullableEnumVisibilityFieldUpdateOperationsInput
  DisplayName: NullableStringFieldUpdateOperationsInput
  Email: StringFieldUpdateOperationsInput
  FK_Courses: CourseOnUserUpdateManyWithoutFK_UserInput
  FK_FlashCardStacks: FlashCardStackUpdateManyWithoutFK_UserInput
  FK_FlowTags: FlowTagUpdateManyWithoutFK_UserInput
  FK_Flows: FlowUpdateManyWithoutFK_UserInput
  ProfilePictureLink: NullableStringFieldUpdateOperationsInput
  UID: NullableStringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  DefaultVisibility: NullableEnumVisibilityFieldUpdateOperationsInput
  DisplayName: NullableStringFieldUpdateOperationsInput
  Email: StringFieldUpdateOperationsInput
  ProfilePictureLink: NullableStringFieldUpdateOperationsInput
  UID: NullableStringFieldUpdateOperationsInput
}

input UserUpdateOneWithoutFK_CoursesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutFK_CoursesInput
  create: UserCreateWithoutFK_CoursesInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutFK_CoursesInput
  upsert: UserUpsertWithoutFK_CoursesInput
}

input UserUpdateOneWithoutFK_FlashCardStacksInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutFK_FlashCardStacksInput
  create: UserCreateWithoutFK_FlashCardStacksInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutFK_FlashCardStacksInput
  upsert: UserUpsertWithoutFK_FlashCardStacksInput
}

input UserUpdateOneWithoutFK_FlowTagsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutFK_FlowTagsInput
  create: UserCreateWithoutFK_FlowTagsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutFK_FlowTagsInput
  upsert: UserUpsertWithoutFK_FlowTagsInput
}

input UserUpdateOneWithoutFK_FlowsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutFK_FlowsInput
  create: UserCreateWithoutFK_FlowsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutFK_FlowsInput
  upsert: UserUpsertWithoutFK_FlowsInput
}

input UserUpdateWithoutFK_CoursesInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  DefaultVisibility: NullableEnumVisibilityFieldUpdateOperationsInput
  DisplayName: NullableStringFieldUpdateOperationsInput
  Email: StringFieldUpdateOperationsInput
  FK_FlashCardStacks: FlashCardStackUpdateManyWithoutFK_UserInput
  FK_FlowTags: FlowTagUpdateManyWithoutFK_UserInput
  FK_Flows: FlowUpdateManyWithoutFK_UserInput
  ProfilePictureLink: NullableStringFieldUpdateOperationsInput
  UID: NullableStringFieldUpdateOperationsInput
}

input UserUpdateWithoutFK_FlashCardStacksInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  DefaultVisibility: NullableEnumVisibilityFieldUpdateOperationsInput
  DisplayName: NullableStringFieldUpdateOperationsInput
  Email: StringFieldUpdateOperationsInput
  FK_Courses: CourseOnUserUpdateManyWithoutFK_UserInput
  FK_FlowTags: FlowTagUpdateManyWithoutFK_UserInput
  FK_Flows: FlowUpdateManyWithoutFK_UserInput
  ProfilePictureLink: NullableStringFieldUpdateOperationsInput
  UID: NullableStringFieldUpdateOperationsInput
}

input UserUpdateWithoutFK_FlowTagsInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  DefaultVisibility: NullableEnumVisibilityFieldUpdateOperationsInput
  DisplayName: NullableStringFieldUpdateOperationsInput
  Email: StringFieldUpdateOperationsInput
  FK_Courses: CourseOnUserUpdateManyWithoutFK_UserInput
  FK_FlashCardStacks: FlashCardStackUpdateManyWithoutFK_UserInput
  FK_Flows: FlowUpdateManyWithoutFK_UserInput
  ProfilePictureLink: NullableStringFieldUpdateOperationsInput
  UID: NullableStringFieldUpdateOperationsInput
}

input UserUpdateWithoutFK_FlowsInput {
  CreatedTime: DateTimeFieldUpdateOperationsInput
  DefaultVisibility: NullableEnumVisibilityFieldUpdateOperationsInput
  DisplayName: NullableStringFieldUpdateOperationsInput
  Email: StringFieldUpdateOperationsInput
  FK_Courses: CourseOnUserUpdateManyWithoutFK_UserInput
  FK_FlashCardStacks: FlashCardStackUpdateManyWithoutFK_UserInput
  FK_FlowTags: FlowTagUpdateManyWithoutFK_UserInput
  ProfilePictureLink: NullableStringFieldUpdateOperationsInput
  UID: NullableStringFieldUpdateOperationsInput
}

input UserUpsertWithoutFK_CoursesInput {
  create: UserCreateWithoutFK_CoursesInput!
  update: UserUpdateWithoutFK_CoursesInput!
}

input UserUpsertWithoutFK_FlashCardStacksInput {
  create: UserCreateWithoutFK_FlashCardStacksInput!
  update: UserUpdateWithoutFK_FlashCardStacksInput!
}

input UserUpsertWithoutFK_FlowTagsInput {
  create: UserCreateWithoutFK_FlowTagsInput!
  update: UserUpdateWithoutFK_FlowTagsInput!
}

input UserUpsertWithoutFK_FlowsInput {
  create: UserCreateWithoutFK_FlowsInput!
  update: UserUpdateWithoutFK_FlowsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  CreatedTime: DateTimeFilter
  DefaultVisibility: EnumVisibilityNullableFilter
  DisplayName: StringNullableFilter
  Email: StringFilter
  FK_Courses: CourseOnUserListRelationFilter
  FK_FlashCardStacks: FlashCardStackListRelationFilter
  FK_FlowTags: FlowTagListRelationFilter
  FK_Flows: FlowListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  ProfilePictureLink: StringNullableFilter
  UID: StringNullableFilter
  UserID: IntFilter
}

input UserWhereUniqueInput {
  UserID: Int
}

enum Visibility {
  HIDDEN
  PRIVATE
  PUBLIC
}
